==================================================
소스.cpp2023-09-11 월요일 오후 5:31:43
==================================================
// 2023. 9. 11 월										(2주 1일)
//---------------------------------------------------------------------------
// C++ 입출력 - C++20기준
//---------------------------------------------------------------------------
// 과제 C++ I/O 관련 내용 읽어보기
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

//--------
int main()
//--------
{

	save("소스.cpp");
}


==================================================
소스.cpp2023-09-11 월요일 오후 5:36:08
==================================================
// 2023. 9. 11 월										(2주 1일)
//---------------------------------------------------------------------------
// C++ 입출력 - C++20기준
//---------------------------------------------------------------------------
// 과제 C++ I/O 관련 내용 읽어보기
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//--------
int main()				// cin, cout, cerr, clog
//--------
{
	// 화면에 구구단 2단부터 9단까지 출력하세요.
	for (int j = 2; j <= 9; ++j) {
		for (int i = 1; i <= 9; ++i) {
			cout << j << " x " << i << " = " << j * i << '\n';
		}
	}
	save("소스.cpp");
}


==================================================
소스.cpp2023-09-11 월요일 오후 5:44:17
==================================================
// 2023. 9. 11 월										(2주 1일)
//---------------------------------------------------------------------------
// C++ 입출력 - C++20기준
//---------------------------------------------------------------------------
// 과제 C++ I/O 관련 내용 읽어보기
//---------------------------------------------------------------------------

#include <iostream>
#include <format>		// C++20 출력문을 정렬
#include "save.h"
using namespace std;

//--------
int main()				// cin, cout, cerr, clog
//--------
{
	// 화면에 구구단 2단부터 9단까지 출력하세요.
	// Coding convention
	for (int j = 2; j <= 9; ++j) {
		for (int i = 1; i <= 9; ++i) {
			cout << j << " x " << i << " = " << 
				format("{:2d}",j * i) << endl;	// format에서 출력하는 데이터를 {}로 표현(%d랑 같음) 그리고 형식지정은 콜론(:)으로 함
		}										// < : 왼쪽정렬, > : 오른쪽 정렬, ^ : 가운데 정렬
		cout << endl;
	}
	save("소스.cpp");
}


==================================================
소스.cpp2023-09-11 월요일 오후 5:51:21
==================================================
// 2023. 9. 11 월										(2주 1일)
//---------------------------------------------------------------------------
// C++ 입출력 - C++20기준
//---------------------------------------------------------------------------
// 과제 C++ I/O 관련 내용 읽어보기
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()				// cin, cout, cerr, clog
//--------
{
	// [문제] int 값 2를 입력받아 합계를 출력하라
	int a, b;

	cout << "두 수의 합 구하기" << endl;
	cout << "a를 입력하세요" << endl;
	cin >> a;
	cout << "b를 입력하세요" << endl;
	cin >> b;

	int result = a + b;
	cout << "합계: " << result << endl;

	save("소스.cpp");
}


==================================================
소스.cpp2023-09-11 월요일 오후 6:26:07
==================================================
// 2023. 9. 11 월										(2주 1일)
//---------------------------------------------------------------------------
// int n;
//---------------------------------------------------------------------------
// 과제 C++ I/O 관련 내용 읽어보기
// 과제 - 다른 자료형에 대하여 오늘 강의한 내용을 반복
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;	// 이렇게 하면 안되는 이유를 알고 쓰자.

//--------
int main()				// cin, cout, cerr, clog
//--------
{
	int n;	// 여기서 int 는 최소 단위로 사용되는 token
	// #    include      <     iostream       > 을 사용해도 문제 없는 것처럼 토큰으로 이루어짐
	
	save("소스.cpp");
}


==================================================
소스.cpp2023-09-11 월요일 오후 6:28:15
==================================================
// 2023. 9. 11 월										(2주 1일)
//---------------------------------------------------------------------------
// int n;
//---------------------------------------------------------------------------
// 과제 C++ I/O 관련 내용 읽어보기
// 과제 - 다른 자료형에 대하여 오늘 강의한 내용을 반복
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;	// 이렇게 하면 안되는 이유를 알고 쓰자.

//--------
int main()				// cin, cout, cerr, clog
//--------
{
	int n;	// int 만큼 메모리를 주세요. 나는 n이라는 이름으로 access
	
	cout << "n의 크기는 - " << sizeof(n) << endl;
	cout << "n의 주소는 - " << addressof(n) << endl;
	cout << "n의 자료형은 - " << typeid(n).name() << endl;

	// int 의 크기는 C++표준에 따르면 적어도 2바이트 

	save("소스.cpp");
}



==================================================
소스.cpp2023-09-11 월요일 오후 6:45:56
==================================================
// 2023. 9. 11 월										(2주 1일)
//---------------------------------------------------------------------------
// int n;
//---------------------------------------------------------------------------
// 과제 C++ I/O 관련 내용 읽어보기
// 과제 - 다른 자료형에 대하여 오늘 강의한 내용을 반복
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;	// 이렇게 하면 안되는 이유를 알고 쓰자.

//--------
int main()				// cin, cout, cerr, clog
//--------
{
	int n = 0B01111111'11111111'11111111'11111111;

	// [문제] n의 최댓값을 출력하라
	
	cout << n << endl;

	n = n + 1;
	// [문제] n의 최솟값을 출력하라

	cout << n << endl;

	save("소스.cpp");
}


==================================================
소스.cpp2023-09-11 월요일 오후 6:56:30
==================================================
// 2023. 9. 11 월										(2주 1일)
//---------------------------------------------------------------------------
// int n;
//---------------------------------------------------------------------------
// 과제 C++ I/O 관련 내용 읽어보기
// 과제 - 다른 자료형에 대하여 오늘 강의한 내용을 반복
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;	

//--------
int main()				
//--------
{

	cout << numeric_limits<long long int>::max() << endl;

	save("소스.cpp");
}


==================================================
소스.cpp2023-09-13 수요일 오후 4:10:40
==================================================
// 2023. 9. 13 수										(2주 2일)
// 다음 주 수요일 9/20 - 전시로 수업(3주 2일)을 대체 함
//---------------------------------------------------------------------------
// int n;
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;	

//--------
int main()				
//--------
{
	int n[10];

	// [문제] n에는 int 값 10개가 있다. 화면에 출력하라
	for (int i = 0; i < 10; ++i) {
		cout << "n[" << i << "] 의 값 - " << n[i] << endl;
	}
	save("소스.cpp");
}


==================================================
소스.cpp2023-09-13 수요일 오후 4:21:54
==================================================
// 2023. 9. 13 수										(2주 2일)
// 다음 주 수요일 9/20 - 전시로 수업(3주 2일)을 대체 함
//---------------------------------------------------------------------------
// int n;
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;	

//--------
int main()				
//--------
{
	int n[10];

	// [문제] n에는 int 값 10개가 있다. 화면에 출력하라
	for (int num : n) {			// range-based for, range for loop
		cout << num << endl;
	}
	save("소스.cpp");
}


==================================================
소스.cpp2023-09-13 수요일 오후 4:24:56
==================================================
// 2023. 9. 13 수										(2주 2일)
// 다음 주 수요일 9/20 - 전시로 수업(3주 2일)을 대체 함
//---------------------------------------------------------------------------
// int n;
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;	

//--------
int main()				
//--------
{
	int n[10]{};		// 전체를 0으로 초기화 uniform initialization

	// [문제] n에는 int 값 10개가 있다. 화면에 출력하라
	for (int num : n) {			// range-based for, range for loop
		cout << num << endl;
	}
	save("소스.cpp");
}


==================================================
소스.cpp2023-09-13 수요일 오후 4:41:24
==================================================
// 2023. 9. 13 수										(2주 2일)
// 다음 주 수요일 9/20 - 전시로 수업(3주 2일)을 대체 함
//---------------------------------------------------------------------------
// int n;
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;	

//--------
int main()				
//--------
{
	int n = 1234;		// initialization
	n = 1234;			// 대입, 할당, 배정 - assignment

	save("소스.cpp");
}


==================================================
소스.cpp2023-09-13 수요일 오후 5:06:40
==================================================
// 2023. 9. 13 수										(2주 2일)
// 다음 주 수요일 9/20 - 전시로 수업(3주 2일)을 대체 함
//---------------------------------------------------------------------------
// 랜덤 엔진과 분포
//---------------------------------------------------------------------------

#include <iostream>
#include <random>			// 랜덤값과 분포를 사용하려면
#include <format>
#include <algorithm>
#include "save.h"
using namespace std;	

default_random_engine dre;				// 랜덤값을 생성하는 엔진
uniform_int_distribution uid{1, 999};

//--------
int main()				
//--------
{
	int numbers[100];

	for (int i = 0; i < 100; ++i) {
		numbers[i] = uid(dre);
	}

	for (int num : numbers) {
		cout << format("{:4d}", num);
	}
	cout << endl;

	int max = numeric_limits<int>::min();
	// [문제] 제일 큰 값을 찾아 화면에 입력하시오
	for (int num : numbers) {
		if (num > max) {
			max = num;
		}
	}
	cout << "제일 큰 값 - " << max << endl;
	
	save("소스.cpp");
}


==================================================
소스.cpp2023-09-18 월요일 오후 6:52:09
==================================================
// 2023. 9. 18 월										(3주 1일)
// 이번 주 수요일 9/20 - 전시로 수업(3주 2일)을 대체 함
//---------------------------------------------------------------------------
// 많은 수의 int가 있다 - 어떻게 저장할건가? 어떤 작업을 하고 싶나?
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <format>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution uid{ 1, 6 };

// [문제] 주사위를 1'0000 번 던졌다. 각 숫자의 출현 횟수와 확률을 출력하라
// 1 - 1670번, 확률 - 16.7%
// ...


//--------
int main()
//--------
{
	int nums[6]{};

	for (int i = 0; i < 1'0000; ++i) {
		nums[uid(dre) - 1]++;
	}

	for (int k = 0; k < 6; ++k) {
		cout << k + 1 << " - " << nums[k] << "번, 확률 - " << format("{:2.1f}", nums[k] / 100.0) << "%" << endl;
	}

	save("소스.cpp");
}


==================================================
소스.cpp2023-09-25 월요일 오후 6:17:10
==================================================
// 2023. 9. 25 월										(4주 1일)
// 10월 2일 (5주 1일) - 동영상 강의
// 10월 25일(6주 2일) - 중간시험
//---------------------------------------------------------------------------
// 변수와 메모리 - 전역변수, 지역변수, 동적할당 변수
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	const int NUM = 25'0000;
	int num[NUM];				// 1MB = 1024KB = 1024 * 1024B

	cout << num[NUM- 1] << endl;
	cout << addressof(num[NUM - 1]) << endl;

	// 오류가 나는 이유 : STACK 오버플로우가 발생하기 때문(STACK의 최대 크기 1MB)
	// STACK의 구조 : LIFO
	// STACK은 함수의 인자를 전달해줌, 함수 호출시 cpu 현 상태를 저장함 
	//								  -> main 함수를 돌다가 다른 함수를 호출할 때 다른 함수 호출 전까지의 main 함수의 상태를 STACK에 저장함 

	save("소스.cpp");
}

==================================================
소스.cpp2023-09-25 월요일 오후 6:55:13
==================================================
// 2023. 9. 25 월										(4주 1일)
// 10월 2일 (5주 1일) - 동영상 강의
// 10월 25일(6주 2일) - 중간시험
//---------------------------------------------------------------------------
// 변수와 메모리 - 전역변수, 지역변수, 동적할당 변수
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

int n;				// DATA - global variable

//--------
int main()
//--------
{
	int n;			// STACK - local variable
					// DATA, STACK은 n이란 이름으로 주소값에 엑세스하여 그 안의 값을 다룸

	new int;		// FREE Store - dynamically allocated variable -> DATA와 STACK이랑 다르게 주소값만 가지고 다룸
	// -> system(Operating system)에 요청
	save("소스.cpp");
}

==================================================
소스.cpp2023-09-25 월요일 오후 7:02:04
==================================================
// 2023. 9. 25 월										(4주 1일)
// 10월 2일 (5주 1일) - 동영상 강의
// 10월 25일(6주 2일) - 중간시험
//---------------------------------------------------------------------------
// 변수와 메모리 - 전역변수, 지역변수, 동적할당 변수
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

int gn[10];

//--------
int main()
//--------
{
	int n[10];

	int* p = new int[10];

	// 각 int는 살고 있는 곳이 다르다

	cout << addressof(n) << endl;
	cout << addressof(gn) << endl;
	cout << p << endl;

	// STACK : n, p
	// DATA : n
	// Free Store : new int

	save("소스.cpp");
}

==================================================
소스.cpp2023-09-27 수요일 오후 3:57:01
==================================================
// 2023. 9. 27 월										(4주 2일)
// 10월 2일 (5주 1일) - 동영상 강의
// 10월 25일(6주 2일) - 중간시험
//---------------------------------------------------------------------------
// change 함수
//---------------------------------------------------------------------------
// 정렬
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void change(int*, int*);		// function declaration : 선언

//--------
int main()
//--------
{
	int a{ 1 }, b{ 2 };
	
	// 여기서 함수 change를 호출하여 a와 b의 값을 서로 바꾸는 코딩을 한다.
	// 원하는 출력값이 예시와 같이 나오도록
	// 함수 change를 선언하고 정의한 후 호출하라

	change(&a, &b);				// function call : 호출
	cout << a << ", " << b << endl;		// 예시) 2, 1

	save("소스.cpp");
}

void change(int* p, int* q) {	// function definition : 정의
	int temp{ *p };
	*p = *q;
	*q = temp;
}


==================================================
소스.cpp2023-09-27 수요일 오후 4:43:24
==================================================
// 2023. 9. 27 월										(4주 2일)
// 10월 2일 (5주 1일) - 동영상 강의
// 10월 25일(6주 2일) - 중간시험
//---------------------------------------------------------------------------
// change 함수
//---------------------------------------------------------------------------
// 정렬
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void change(int&, int&);			// call-by reference

//--------
int main()
//--------
{
	int a{ 1 }, b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;
	save("소스.cpp");
}

void change(int& p, int& q) {
	int temp{ p };
	p = q;
	q = temp;
}

==================================================
소스.cpp2023-09-27 수요일 오후 5:01:17
==================================================
// 2023. 9. 27 월										(4주 2일)
// 10월 2일 (5주 1일) - 동영상 강의
// 10월 25일(6주 2일) - 중간시험
//---------------------------------------------------------------------------
// change 함수
//---------------------------------------------------------------------------
// 정렬
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void change(int&, int&);			// 선언과 정의를 반드시 나눠야함

//--------
int main()
//--------
{
	int num[]{ 10, 3, 8, 6, 1, 5, 2, 7, 4, 9 };

	// [문제] num에 있는 값 중 제일 큰 값을 오른쪽으로 옮겨라
	int size = sizeof(num) / sizeof(int);

	for (int i = 0; i < size - 1; ++i) {
		if (num[i] > num[i + 1]) {
			change(num[i], num[i + 1]);
		}
	}

	for (int num : num) {
		cout << num << " ";
	}
	cout << endl;

	save("소스.cpp");
}

void change(int& p, int& q) {
	int temp{ p };
	p = q;
	q = temp;
}


==================================================
소스.cpp2023-09-27 수요일 오후 5:17:10
==================================================
// 2023. 9. 27 월										(4주 2일)
// 10월 2일 (5주 1일) - 동영상 강의
// 10월 25일(6주 2일) - 중간시험
//---------------------------------------------------------------------------
// change 함수
//---------------------------------------------------------------------------
// 정렬
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void change(int&, int&);			// 선언과 정의를 반드시 나눠야함
									// * & : 다른 지역에 있는 메모리에 엑세스하기 위해 사용

//--------
int main()
//--------
{
	const int NUM = 10;
	int num[NUM]{ 10, 3, 8, 6, 1, 5, 2, 7, 4, 9 };

	// [문제] num에 있는 값 중 제일 큰 값을 오른쪽으로 옮겨라
	
	// buble sort
	for (int k = 1; k < NUM - 2; ++k) {
		for (int i = 0; i < NUM - k; ++i) {
			if (num[i] > num[i + 1]) {
				change(num[i], num[i + 1]);
			}
		}
	}

	for (int num : num) {
		cout << num << " ";
	}
	cout << endl;

	save("소스.cpp");
}

void change(int& p, int& q) {
	int temp{ p };
	p = q;
	q = temp;
}


==================================================
소스.cpp2023-10-04 수요일 오후 1:57:50
==================================================
// 2023. 10. 2 월										(5주 1일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 정렬(sort)
//---------------------------------------------------------------------------

#include <iostream>
#include <format>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution uid{ 1, 999 };

// [문제] int 값 1'000개를 저장할 수 있는 배열을 만들어라
// 각 int값을 1부터 999까지 값 중 랜덤값으로 만들어라
// 배열을 오름차순으로 정렬하라
// 전체 1000개 값을 화면에 출력하라

//--------
int main()
//--------
{
	int num[1000];		// 4KB

	for (int i = 0; i < 1000; ++i) {
		num[i] = uid(dre);
	}

	// 정렬 - bubble sort
	for (int j = 0; j < 1000 - 1; ++j) {
		for (int i = 0; i < 1000 - 1; ++i) {
			if (num[i] > num[i + 1]) {
				int temp{ num[i] };
				num[i] = num[i + 1];
				num[i + 1] = temp;
			}
		}
	}

	// 정렬 후 출력
	for (int num : num) {
		cout << format("{:4d}",num);
	}
	cout << '\n';
	save("소스.cpp");
}


==================================================
소스.cpp2023-10-04 수요일 오후 2:03:59
==================================================
// 2023. 10. 2 월										(5주 1일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 정렬(sort)
//---------------------------------------------------------------------------

#include <iostream>
#include <format>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution uid{ 1, 999 };

// [문제] int 값 1'000개를 저장할 수 있는 배열을 만들어라
// 각 int값을 1부터 999까지 값 중 랜덤값으로 만들어라
// 배열을 내림차순(descending order)으로 정렬하라
// 전체 1000개 값을 화면에 출력하라

//--------
int main()
//--------
{
	const int NUM{ 1000 };
	int num[NUM];		

	for (int i = 0; i < NUM; ++i) {
		num[i] = uid(dre);
	}

	// 정렬 - bubble sort
	for (int j = 0; j < NUM - 1; ++j) {
		for (int i = 0; i < NUM - 1; ++i) {
			if (num[i] < num[i + 1]) {
				int temp{ num[i] };
				num[i] = num[i + 1];
				num[i + 1] = temp;
			}
		}
	}

	// 정렬 후 출력
	for (int num : num) {
		cout << format("{:4d}",num);
	}
	cout << '\n';
	save("소스.cpp");
}


==================================================
소스.cpp2023-10-04 수요일 오후 2:54:14
==================================================
// 2023. 10. 2 월										(5주 1일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 정렬(sort) - C언어 라이브러리 함수 qsort
//---------------------------------------------------------------------------

#include <iostream>
#include <format>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 값 여러개를 저장할 수 있는 배열을 만들어라
// 각 int값을 1부터 99'9999까지 값 중 랜덤값으로 만들어라
// 배열을 오름차순으로 정렬하라
// 일부분을 출력해서 정렬된 것을 확인하자

default_random_engine dre;
uniform_int_distribution uid{ 1, 99'9999 };
//--------
int main()
//--------
{
	const int NUM{ 1000 };
	int num[NUM];

	// &는 원래 데이터에 붙인 별명이니까 원본을 그대로 사용하고 싶을 떄 쓴다
	for (int& number : num) {
		number = uid(dre);
	}

	// 정렬 - qsort

	int 정렬방법(const void*,const void*);
	qsort(num, NUM, sizeof(int), 정렬방법);

	// 정렬 후 출력
	for (int num : num) {
		cout << format("{:8d}",num);
	}
	cout << '\n';
	save("소스.cpp");
}

int 정렬방법(const void* p, const void* q) {
	int a = *(int*)p;
	int b = *(int*)q;

	// 오름차순
	if (a > b) {
		return 1;
	}
	else if (a < b) {
		return -1;
	}

	return 0;

}


==================================================
소스.cpp2023-10-04 수요일 오후 4:12:55
==================================================
// 2023. 10. 4 수										(5주 2일)
// 10월 9일(6주 1일) - 동영상 강의
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 정렬(sort) - C언어 라이브러리 함수 qsort
//---------------------------------------------------------------------------

#include <iostream>
#include <format>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 값 여러개를 저장할 수 있는 배열을 만들어라
// 각 int값을 1부터 99'9999까지 값 중 랜덤값으로 만들어라
// 배열을 오름차순으로 정렬하라
// 일부분을 출력해서 정렬된 것을 확인하자

default_random_engine dre;
uniform_int_distribution uid{ 1, 99'9999 };

int 비교함수(const void*,const void*);

//--------
int main()
//--------
{
	const int NUM{ 20'0000 };
	int num[NUM];
	
	// &는 원래 데이터에 붙인 별명이니까 원본을 그대로 사용하고 싶을 떄 쓴다
	for (int& number : num) {
		number = uid(dre);
	}

	// 정렬 - qsort
	qsort(num, NUM, sizeof(int), 비교함수);		// generic function

	// 정렬 후 출력
	for (int num : num) {
		cout << format("{:8d}",num);
	}
	cout << '\n';
	save("소스.cpp");
}

int 비교함수(const void* a, const void* b) {
	return *(int*)a - *(int*)b;
}


==================================================
소스.cpp2023-10-04 수요일 오후 4:16:36
==================================================
// 2023. 10. 4 수										(5주 2일)
// 10월 9일(6주 1일) - 동영상 강의
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 정렬(sort) - C언어 라이브러리 함수 qsort
//---------------------------------------------------------------------------

#include <iostream>
#include <format>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 값 여러개를 저장할 수 있는 배열을 만들어라
// 각 int값을 1부터 99'9999까지 값 중 랜덤값으로 만들어라
// 배열을 오름차순으로 정렬하라
// 일부분을 출력해서 정렬된 것을 확인하자

default_random_engine dre;
uniform_int_distribution uid{ 1, 99'9999 };

int cnt;
int 비교함수(const void*,const void*);

//--------
int main()
//--------
{
	const int NUM{ 20 };
	int num[NUM];
	
	// &는 원래 데이터에 붙인 별명이니까 원본을 그대로 사용하고 싶을 떄 쓴다
	for (int& number : num) {
		number = uid(dre);
	}

	// 정렬 - qsort
	qsort(num, NUM, sizeof(int), 비교함수);		// generic function

	// 정렬 후 출력
	for (int num : num) {
		cout << format("{:8d}",num);
	}
	cout << "비교함수 호출 횟수 : " << cnt << '\n';
	save("소스.cpp");
}

int 비교함수(const void* a, const void* b) {
	++cnt;
	cout << "비교 - " << *(int*)a << ", " << *(int*)b << endl;
	return *(int*)a - *(int*)b;
}


==================================================
소스.cpp2023-10-04 수요일 오후 4:57:08
==================================================
// 2023. 10. 4 수										(5주 2일)
// 10월 9일(6주 1일) - 동영상 강의
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 정렬(sort) - C언어 라이브러리 함수 qsort
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

int comp(const void*, const void*);

//--------
int main()
//--------
{
	char p[] = "the quick brown fox jumps over the lazy dog";
	cout << p << endl;

	// [문제] p를 오름차순으로 정렬한 후 출력하라
	qsort(p, strlen(p), sizeof(char), comp);

	cout << p << endl;
	
	save("소스.cpp");
}

int comp(const void* a, const void* b) {
	return *(char*)a - *(char*)b;
}


==================================================
소스.cpp2023-10-04 수요일 오후 4:58:34
==================================================
// 2023. 10. 4 수										(5주 2일)
// 10월 9일(6주 1일) - 동영상 강의
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 정렬(sort) - C언어 라이브러리 함수 qsort
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	char p[] = "the quick brown fox jumps over the lazy dog";
	cout << p << endl;

	// [문제] p를 오름차순으로 정렬한 후 출력하라
	qsort(p, strlen(p), sizeof(char), [](const void* a, const void* b) {
		return *(char*)a - *(char*)b; }
	);

	cout << p << endl;
	
	save("소스.cpp");
}


==================================================
소스.cpp2023-10-04 수요일 오후 5:05:32
==================================================
// 2023. 10. 4 수										(5주 2일)
// 10월 9일(6주 1일) - 동영상 강의
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 정렬(sort) - C언어 라이브러리 함수 qsort
//---------------------------------------------------------------------------
// 과제 - 이름없는 함수 람다(lambda)
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	auto x = []() {
		cout << "안녕 난 람다라고 해 반가워!" << endl;
		};
	x();				// 이런 식으로 이름 붙이는 거는 무의미한 행동

	save("소스.cpp");
}


==================================================
소스.cpp2023-10-10 화요일 오후 8:55:38
==================================================
// 2023. 10. 9 월										(6주 1일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 실행 파일과 메모리(DATA)
//---------------------------------------------------------------------------
// 과제 - C++ STACK DATA CODE Free Store
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 사용할 수 있는 전역변수의 크기는 ? 2GB로 제한되어 있음
char a[1'000'000'000];

//--------
int main()
//--------
{
	cout << static_cast<int>(a[0]) << endl;
	save("소스.cpp");
}


==================================================
소스.cpp2023-10-10 화요일 오후 9:02:32
==================================================
// 2023. 10. 9 월										(6주 1일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 실행 파일과 메모리(DATA)
//---------------------------------------------------------------------------
// 과제 - C++ STACK DATA CODE Free Store
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행한 후 실행 파일의 크기를 살표보세요
char a[1'000'000'000] { 'a', 'b', 'c' };
// 이 문장이 오래 걸리는 이유 : 'a' 'b' 'c' 0 0 0 ... 1GB만큼 exe파일에 생성후 실행될 때 
// 하드디스크에 기록된 .exe 파일을 메모리에 올리는데 시간이 오래걸림

//--------
int main()
//--------
{
	cout << a[0] << endl;			// a
	save("소스.cpp");
}


==================================================
소스.cpp2023-10-10 화요일 오후 9:35:05
==================================================
// 2023. 10. 9 월										(6주 1일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 실행 파일과 메모리(Free Store)
//---------------------------------------------------------------------------
// 과제 - C++ STACK DATA CODE Free Store
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	int* p;				// STACK에 8 바이트 할당

	p = new int;		// DATA에 4 바이트 할당 -> 여기서 할당된 메모리의 시작 주소를 p 에 저장함

	*p = 123;			// p 주소에 123으로 값을 씀
	cout << *p << endl;

	save("소스.cpp");
}


==================================================
소스.cpp2023-10-10 화요일 오후 9:44:54
==================================================
// 2023. 10. 9 월										(6주 1일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 실행 파일과 메모리(Free Store)
//---------------------------------------------------------------------------
// 과제 - C++ STACK DATA CODE Free Store
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 사용자가 정수 num을 입력한다.
// int 를 num 개 만큼 저장할 공간을 확보한다.
// 그 공간을 1부터 시작하는 정수로 채운다. [1, num]
// int 값의 합계를 화면에 출력하라.
// 이 과정을 계속 반복하라.

//--------
int main()
//--------
{
	save("소스.cpp");

	while (true) {
		cout << "int 값을 입력하세요 - ";
		int num;
		cin >> num;

		int* p = new int[num];

		for (int i = 0; i < num; ++i) {
			p[i] = i + 1;
		}

		// 합계 계산
		int sum{};
		for (int i = 0; i < num; ++i) {
			sum += p[i];
		}

		cout << "1부터 " << num << "까지 합계 = " << sum << endl;
	}
}


==================================================
소스.cpp2023-10-10 화요일 오후 10:14:03
==================================================
// 2023. 10. 9 월										(6주 1일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 실행 파일과 메모리(Free Store)
//---------------------------------------------------------------------------
// 과제 - C++ STACK DATA CODE Free Store
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 사용자가 정수 num을 입력한다.
// int 를 num 개 만큼 저장할 공간을 확보한다.
// 그 공간을 1부터 시작하는 정수로 채운다. [1, num]
// int 값의 합계를 화면에 출력하라.
// 이 과정을 계속 반복하라.

//--------
int main()
//--------
{
	save("소스.cpp");

	while (true) {
		cout << "int 값을 입력하세요 - ";
		int num;
		cin >> num;

		int* p = new int[num];

		for (int i = 0; i < num; ++i) {
			p[i] = i + 1;
		}

		// 합계 계산
		int sum{};
		for (int i = 0; i < num; ++i) {
			sum += p[i];
		}

		cout << "1부터 " << num << "까지 합계 = " << sum << endl;
		
		delete[] p;			// 동적 할당을 하고 나서 끝날 때 반드시 메모리 할당을 해제 해야함
	}
}


==================================================
소스.cpp2023-10-10 화요일 오후 10:19:43
==================================================
// 2023. 10. 9 월										(6주 1일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 실행 파일과 메모리(Free Store)
//---------------------------------------------------------------------------
// 과제 - C++ STACK DATA CODE Free Store
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	save("소스.cpp");
	int cnt{};
	while (true) {
		// 메모리 1GB 동적할당
		try	{
			new char[1'000'000'000];			// 할당해줄 메모리가 없으면 시스템은 예외를 던진다
		}
		catch (exception& e) {
			cout << e.what() << endl;
			return 333;
		}
		cout << ++cnt << "기가 바이트 요청" << endl;
	}
}



==================================================
소스.cpp2023-10-10 화요일 오후 10:28:38
==================================================
// 2023. 10. 9 월										(6주 1일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 실행 파일과 메모리(Free Store)
//---------------------------------------------------------------------------
// 과제 - C++ STACK DATA CODE Free Store
//---------------------------------------------------------------------------

#include <iostream>
#include <chrono>
#include "save.h"
using namespace std;

// [관찰] 윈도우의 메모리 관리를 확인해 본다(ctrl + alt + delete)

//--------
int main()
//--------
{
	save("소스.cpp");
	int cnt{};
	while (true) {
		new char[1'000'000'000] {1, 2, 3};
		cout << ++cnt << "기가 요청" << endl;
		this_thread::sleep_for(3s);				// 3초 쉰다
	}
}


==================================================
소스.cpp2023-10-11 수요일 오후 3:49:13
==================================================
// 2023. 10. 11 수										(6주 2일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// [실습] 배열에 있는 많은 데이터를 읽고 쓰기
//---------------------------------------------------------------------------
// [과제] 값을 바꿔가며 반복 연습
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] 파일에 1부터 100까지 정수를 출력하라

//--------
int main()
//--------
{
	ofstream 파일{ "1부터 100까지" };

	for (int i = 0; i < 100; ++i) {
		파일 << i + 1 << ' ';
	}
	파일 << endl;
	save("소스.cpp");

}


==================================================
소스.cpp2023-10-11 수요일 오후 4:03:36
==================================================
// 2023. 10. 11 수										(6주 2일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// [실습] 배열에 있는 많은 데이터를 읽고 쓰기
//---------------------------------------------------------------------------
// [과제] 값을 바꿔가며 반복 연습
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] "1부터100" 파일에는 int가 100개 기록되어 있다.
// 읽어서 화면에 출력하라

//--------
int main()
//--------
{
	ifstream in{ "1부터 100까지" };			// RAII
	
	if (!in) {
		cout << "해당 파일을 열 수 없습니다." << endl;
		return 0;
	}

	int num;
	
	while (in >> num) {
		cout << num << ' ';
	}
	
	cout << endl;

	save("소스.cpp");
}

==================================================
소스.cpp2023-10-11 수요일 오후 4:18:34
==================================================
// 2023. 10. 11 수										(6주 2일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// [실습] 배열에 있는 많은 데이터를 읽고 쓰기
//---------------------------------------------------------------------------
// [과제] 값을 바꿔가며 반복 연습
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution uid;

//--------
int main()
//--------
{
	ofstream out{ "int만개.txt" };
	for (int i = 0; i < 10000; ++i) {
		out << uid(dre) << ' ';
		if (i % 10 == 0) {
			out << endl;
		}
	}

	save("소스.cpp");
}

==================================================
소스.cpp2023-10-11 수요일 오후 4:51:05
==================================================
// 2023. 10. 11 수										(6주 2일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// [실습] 배열에 있는 많은 데이터를 읽고 쓰기
//---------------------------------------------------------------------------
// [과제] 값을 바꿔가며 반복 연습
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] "int만개.txt"에는 int 값을 10000개가 있다
// 가장 작은 값을찾아 화면에 출력하라 

//--------
int main()
//--------
{
	ifstream in{ "int만개.txt" };
	if (!in) {
		cout << "해당 파일을 열 수 없음" << endl;
		return 0;
	}

	int min{ numeric_limits<int>::max() };
	int n;
	while (in >> n) {
		if (min > n) {
			min = n;
		}
	}

	cout << "최소값 : " << min << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-10-16 월요일 오후 6:04:58
==================================================
// 2023. 10. 16 월										(7주 1일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// [실습] 파일에 데이터를 읽고 쓰기
//---------------------------------------------------------------------------
// [과제] 값을 바꿔 가며 반복 연습한다
//---------------------------------------------------------------------------


#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] "소스.cpp" 에 알파벳 소문자의 개수를 세서 다음과 같이 출력하라
// a - 12
// b - 22
// ...
// z - 0

//--------
int main()
//--------
{
	ifstream in{ "소스.cpp" };
	if (!in) {
		cout << "파일을 열 수 없음" << endl;
		return 0;
	}

	int num[26]{};
	char c;
	while (in >> c) {
		if (islower(c)) {
			++num[c - 'a'];
		}
	}

	for (int i = 0; i < 26; ++i) {
		cout << static_cast<char>('a' + i) << " - " << num[i] << endl;
	}
	
	save("소스.cpp");
}

==================================================
소스.cpp2023-10-16 월요일 오후 6:16:36
==================================================
// 2023. 10. 16 월										(7주 1일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// [실습] 파일에 데이터를 읽고 쓰기
//---------------------------------------------------------------------------
// [과제] 값을 바꿔 가며 반복 연습한다
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] "소스.cpp" 를 읽어 알파벳 소문자를 모두 대문자로 바꿔
// "소스대문자.cpp"에 저장하라

//--------
int main()
//--------
{
	ifstream in{ "소스.cpp" };
	ofstream out{ "소스대문자.cpp" };

	if (!in) {
		cout << "파일을 열 수 없음" << endl;
		return 0;
	}

	char c;
	in >> noskipws;
	while (in >> c) {
		if (islower(c)) {
			c = toupper(c);
		}
		out << c;
	}
	
	save("소스.cpp");
}

==================================================
소스.cpp2023-10-18 수요일 오후 3:42:59
==================================================
// 2023. 10. 18 수										(7주 2일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 사용자 정의 자료형
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test{
public:			// access-modifier, public, private, protected
	int n;
	char c;
};

//--------
int main()
//--------
{
	Test t;

	t.c = 'a';
	t.n = 123;

	cout << sizeof(t) << endl;
	// 8바이트가 잡히는 이유는 컴퓨터 자체에서 5바이트씩 읽는 것 보다 메모리를 더 소모하여
	// 8바이트 단위로 읽는 것이 실행속도가 훨씬 빠르기 때문(더 소모 되는 메모리 : Padding)

	save("소스.cpp");
}

==================================================
소스.cpp2023-10-18 수요일 오후 3:50:07
==================================================
// 2023. 10. 18 수										(7주 2일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 사용자 정의 자료형
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct alignas(64) Test{		// alignas : 메모리를 읽는 단위를 사용자 정의로 수정 가능하게 함
public:			// access-modifier, public, private, protected
	int n;
	char c;
};

//--------
int main()
//--------
{
	Test t;

	t.c = 'a';
	t.n = 123;

	cout << sizeof(t) << endl;
	// 8바이트가 잡히는 이유는 컴퓨터 자체에서 5바이트씩 읽는 것 보다 메모리를 더 소모하여
	// 8바이트 단위로 읽는 것이 실행속도가 훨씬 빠르기 때문(더 소모 되는 메모리 : Padding)

	save("소스.cpp");
}

==================================================
소스.cpp2023-10-18 수요일 오후 4:37:40
==================================================
// 2023. 10. 18 수										(7주 2일)
// 10월 25일(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// 사용자 정의 자료형
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution uid{ -100, 100 };

struct Point2D{
	// data member, member variable
	int x;
	int y;

	void show() {
		cout << "(" << x << ", " << y << ")" << endl;
	}
};

// [실습] 랜덤값을 갖는 Point2D 100개 만들어라
// (x, y)값은 [-100, 100] 이다
// 원점(0, 0)에서 반경 10미만까지 영향을 미치는 폭탄이 터졌다
// 어떤 점이 이 폭탄에 영향을 받는 지 출력하라
// root 값을 구할때는 sqrt 함수를 사용하면 된다

//--------
int main()
//--------
{
	Point2D points[100];	// Point2D : 사용자 정의 자료형, p : 객체
	
	for (Point2D& point : points) {
		point.x = uid(dre);
		point.y = uid(dre);
	}

	for (Point2D& point : points) {
		if (sqrt(point.x * point.x + point.y * point.y) < 10) {
			point.show();
		}
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-10-23 월요일 오후 5:44:45
==================================================
// 2023. 10. 23 월										(8주 1일)
// 10월 25일(8주 2일) - 중간시험, class 문제 x
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include <Windows.h>
#include <mmsystem.h>
#include <string>
#include "save.h"

#pragma comment (lib, "winmm.lib")

using namespace std;

class Dog {
	string name;
	int age;
	 
public:
	Dog() {
		cout << "생성자가 호출됨" << '\n';
		PlaySound(L"dog-bark6.wav", NULL, SND_ASYNC);
	}
};

//--------
int main()
//--------
{
	Dog dog[5];
	
	save("소스.cpp");
}

==================================================
소스.cpp2023-10-23 월요일 오후 5:48:00
==================================================
// 2023. 10. 23 월										(8주 1일)
// 10월 25일(8주 2일) - 중간시험, class 문제 x
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include <Windows.h>
#include <mmsystem.h>
#include <string>
#include "save.h"

#pragma comment (lib, "winmm.lib")

using namespace std;

class Dog {
	string name;
	int age;
	 
public:
	Dog() {
		cout << "생성자가 호출됨" << '\n';
		PlaySound(L"dog-bark6.wav", NULL, SND_ASYNC);
	}

	~Dog() {
		cout << "소멸자가 호출됨" << '\n';
		PlaySound(L"개소멸.wav", NULL, SND_ASYNC);
	}
};

//--------
int main()
//--------
{
	Dog dog[5];
	
	save("소스.cpp");
}

==================================================
소스.cpp2023-10-23 월요일 오후 5:50:42
==================================================
// 2023. 10. 23 월										(8주 1일)
// 10월 25일(8주 2일) - 중간시험, class 문제 x
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include <Windows.h>
#include <mmsystem.h>
#include <string>
#include "save.h"

#pragma comment (lib, "winmm.lib")

using namespace std;

class Dog {
	string name;
	int age;
	 
public:
	Dog() {
		cout << "생성자가 호출됨" << '\n';
		PlaySound(L"dog-bark6.wav", NULL, SND_ASYNC);
	}

	~Dog() {
		cout << "소멸자가 호출됨" << '\n';
		PlaySound(L"개소멸.wav", NULL, SND_ASYNC);
	}
};

//--------
int main()
//--------
{
	cout << "메인 시작" << '\n';
	Dog dog;
	
	save("소스.cpp");
	cout << "메인 끝" << '\n';
}

==================================================
소스.cpp2023-10-23 월요일 오후 6:04:02
==================================================
// 2023. 10. 23 월										(8주 1일)
// 10월 25일(8주 2일) - 중간시험, class 문제 x
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include <Windows.h>
#include <mmsystem.h>
#include <string>
#include "save.h"

#pragma comment (lib, "winmm.lib")

using namespace std;

class Dog {
	string name;
	int age;
	 
public:
	Dog() {
		cout << "생성자가 호출됨" << '\n';
		PlaySound(L"dog-bark6.wav", NULL, SND_ASYNC);
	}

	~Dog() {
		cout << "소멸자가 호출됨" << '\n';
		PlaySound(L"개소멸.wav", NULL, SND_ASYNC);
	}
};

//--------
int main()
//--------
{
	cout << "메인 시작" << '\n';

	// C++은 Dog* p = new Dog; 처럼 메모리할당을 하지 않음
	unique_ptr<Dog> dog{ new Dog };		// RALL
	
	save("소스.cpp");
	cout << "메인 끝" << '\n';
}

==================================================
소스.cpp2023-10-23 월요일 오후 6:13:53
==================================================
// 2023. 10. 23 월										(8주 1일)
// 10월 25일(8주 2일) - 중간시험, class 문제 x
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include <Windows.h>
#include <mmsystem.h>
#include <string>
#include "save.h"

#pragma comment (lib, "winmm.lib")

using namespace std;

class Dog {
	string name;
	int age;
	 
public:
	Dog() {
		cout << "생성자가 호출됨" << '\n';
		PlaySound(L"dog-bark6.wav", NULL, SND_ASYNC);
	}

	Dog(string name, int age) : name{ name }, age{ age } {
		cout << name << " - Dog(string, int) 호출됨" << '\n';
		PlaySound(L"dog-bark6.wav", NULL, SND_ASYNC);
		
	}

	~Dog() {
		cout << name << " - 소멸자가 호출됨" << '\n';
		PlaySound(L"개소멸.wav", NULL, SND_ASYNC);
	}
};

//--------
int main()
//--------
{
	cout << "메인 시작" << '\n';

	Dog dog{ "댕댕"s, 2 };
	
	save("소스.cpp");
	cout << "메인 끝" << '\n';
}

==================================================
소스.cpp2023-10-23 월요일 오후 6:39:02
==================================================
// 2023. 10. 23 월										(8주 1일)
// 10월 25일(8주 2일) - 중간시험, class 문제 x
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include <Windows.h>
#include <mmsystem.h>
#include <string>
#include "save.h"

#pragma comment (lib, "winmm.lib")

using namespace std;

class Dog {
	string name;
	int age;
	 
public:
	Dog() {		// default 생성자
		cout << "생성자가 호출됨" << '\n';
		//PlaySound(L"dog-bark6.wav", NULL, SND_ASYNC);
	}

	Dog(string name, int age) : name{ name }, age{ age } {
		cout << name << " - Dog(string, int) 호출됨" << '\n';
		//PlaySound(L"dog-bark6.wav", NULL, SND_ASYNC);
		
	}

	~Dog() {	// 소멸자
		cout << name << " - 소멸자가 호출됨" << '\n';
		//PlaySound(L"개소멸.wav", NULL, SND_ASYNC);
	}
};

//--------
int main()
//--------
{

	// Class Special Function
	// 1. 생성 -> Dog()
	// 2. 소멸 -> ~Dog()
	// 3. 복사 생성 -> Dog(const Dog&)
	// 4. 복사 할당 -> operator=()
	// 5. 이동 생성 -> Dog(Dog&&)
	// 6. 이동 할당 -> operator=()

	save("소스.cpp");
}

==================================================
소스.cpp2023-10-23 월요일 오후 6:48:12
==================================================
// 2023. 10. 23 월										(8주 1일)
// 10월 25일(8주 2일) - 중간시험, class 문제 x
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include <Windows.h>
#include <mmsystem.h>
#include <string>
#include "save.h"

#pragma comment (lib, "winmm.lib")

using namespace std;

class Dog {
	string name;
	int age;
	 
public:
	Dog() {		// default 생성자
		cout << "생성자가 호출됨" << '\n';
		//PlaySound(L"dog-bark6.wav", NULL, SND_ASYNC);
	}

	Dog(string name, int age) : name{ name }, age{ age } {
		cout << name << " - Dog(string, int) 호출됨" << '\n';
		//PlaySound(L"dog-bark6.wav", NULL, SND_ASYNC);
		
	}

	~Dog() {	// 소멸자
		cout << name << " - 소멸자가 호출됨" << '\n';
		//PlaySound(L"개소멸.wav", NULL, SND_ASYNC);
	}

	// copy constructor - 복사생성자
	Dog(const Dog& other) : name{ other.name }, age{ other.age } {
		cout << name << "을 복사생성함" << '\n';
		//PlaySound(L"개소멸.wav", NULL, SND_ASYNC);
	}
	// copy assignment operator - 복사할당연산자

};

//--------
int main()
//--------
{

	Dog dog { "댕댕"s, 2 };
	Dog x { "x"s, 10 };
	
	Dog d = dog;		// 복사 생성
	d = x;				// 복사 할당

	save("소스.cpp");
}

==================================================
소스.cpp2023-10-23 월요일 오후 7:03:17
==================================================
// 2023. 10. 23 월										(8주 1일)
// 10월 25일(8주 2일) - 중간시험, class 문제 x
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include <Windows.h>
#include <mmsystem.h>
#include <string>
#include "save.h"

#pragma comment (lib, "winmm.lib")

using namespace std;

class Dog {
	string name;
	int age;
	 
public:
	Dog() {		// default 생성자
		cout << "생성자가 호출됨" << '\n';
		//PlaySound(L"dog-bark6.wav", NULL, SND_ASYNC);
	}

	Dog(string name, int age) : name{ name }, age{ age } {
		cout << name << " - Dog(string, int) 호출됨" << '\n';
		//PlaySound(L"dog-bark6.wav", NULL, SND_ASYNC);
		
	}

	~Dog() {	// 소멸자
		cout << name << " - 소멸자가 호출됨" << '\n';
		//PlaySound(L"개소멸.wav", NULL, SND_ASYNC);
	}

	// copy constructor - 복사생성자
	Dog(const Dog& other) : name{ other.name }, age{ other.age } {
		cout << name << "을 복사생성함" << '\n';
		//PlaySound(L"개소멸.wav", NULL, SND_ASYNC);
	}
	// copy assignment operator - 복사할당연산자
	Dog& operator=(const Dog& other) {		
		// 자기자신 할당 금지
		if (this == &other) {
			return *this;
		}

		// 자신의 메모리 정리
		cout << name << "복사할당연산자 호출" << '\n';
		name = other.name;
		cout << name << '\n';
		age = other.age;

		return *this;
	}
};

//--------
int main()
//--------
{

	Dog dog { "댕댕"s, 2 };
	Dog x { "x"s, 10 };
	
	Dog d = dog;		// 복사 생성
	d = x;				// 복사 할당

	save("소스.cpp");
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------------------------

==================================================
소스.cpp2023-10-30 월요일 오후 6:49:28
==================================================
// 2023. 10. 30 월										(9주 1일)
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

// [문제] 나는 Memory Monster다. 생성시에 int 값 num을 전달하면
// Free store에 num개의 int를 저장할 공간을 확보하고 그 값을 모두 num으로 채운다.
// 다음 코드가 문제없이 실행되도록 코딩하자

class MemoryMonster {
	int num;
	int* p;
public:

	MemoryMonster(int n) : num{ n } {
		p = new int[num];
		for (int i = 0; i < num; ++i) {
			p[i] = num;
		}
		cout << "MemoryMonster 생성 - " << num << endl;
	}

	void show() {
		cout << "Monster - " << num << endl;
	}

	~MemoryMonster() {
		cout << "MemoryMonster 소멸 - " << num << endl;
		delete[] p;
	}
};

//--------
int main()
//--------
{
	MemoryMonster a{ 123 };
	MemoryMonster b{ 3333 };

	a.show();		// 화면에 "Monster - 123" 이라고 출력한다
	b.show();

	save("소스.cpp");
}

==================================================
소스.cpp2023-11-06 월요일 오후 5:43:14
==================================================
// 2023. 11. 6 월										(10주 1일)
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

// [문제] 나는 Memory Monster다. 생성시에 int 값 num을 전달하면
// Free store에 num개의 int를 저장할 공간을 확보하고 그 값을 모두 num으로 채운다.
// 다음 코드가 문제없이 실행되도록 코딩하자

class MemoryMonster {
	int num;
	int* p;
public:
	
	MemoryMonster(int n) : num{ n } {
		p = new int[num];
		for (int i = 0; i < num; ++i) {
			p[i] = num;
		}
		cout << "MemoryMonster 생성 - " << num << endl;
	}

	~MemoryMonster() {
		cout << "MemoryMonster 소멸 - " << num << endl;
		delete[] p;
	}

	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];
		memcpy(p, other.p, sizeof(int) * num);

		cout << "메몬을 복사함 - " << num << endl;
	}

	// 복사생성자를 코딩했다면 반드시 이와 짝이 되는 복사할당연산자(copy assignment)를 코딩해야만 한다
	MemoryMonster& operator=(const MemoryMonster& other) {
		delete[] p;		// 내가 관리하는 자원을 해제
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, sizeof(int) * num);

		cout << "메몬을 복사할당함 - " << num << endl;

		return *this;
	}
	void show() {
		cout << "Monster - " << num << endl;
	}


};

//--------
int main()
//--------
{
	MemoryMonster a{ 100 };
	MemoryMonster b{ 500 };

	b = a;			// copy assignment -> operator=()

	save("소스.cpp");
}

==================================================
소스.cpp2023-11-06 월요일 오후 6:19:22
==================================================
// 2023. 11. 6 월										(10주 1일)
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

using namespace std;
class STRING {
	size_t size;
	char* p;
public:

	STRING(const char* s) : size{strlen(s)} {
		p = new char[size];
		memcpy(p, s, size);

		cout << "STRING(const char*) - " << size << ", 번지:" << (void*)p << endl;
	}
	
	~STRING() {
		cout << "~STRING() - " << size << ", 번지:" << (void*)p << endl;
		delete[] p;
	}

	void show() {
		for (int i = 0; i < size; ++i) {
			cout << p[i];
		}

		cout << endl;
	}
};

//--------
int main()
//--------
{	
	// STRING의 생성자는 const char* 로 전달하고 처리하자. string 사용하지 말 것
	STRING s{ "안녕? 난 C의 char*를 완벽하게 대체하는 객체야!" };
	
	s.show();
	save("소스.cpp");
}

==================================================
소스.cpp2023-11-06 월요일 오후 6:30:00
==================================================
// 2023. 11. 6 월										(10주 1일)
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

using namespace std;
class STRING {
	size_t size;
	char* p;
public:

	STRING(const char* s) : size{strlen(s)} {
		p = new char[size];
		memcpy(p, s, size);

		cout << "STRING(const char*) - " << size << ", 번지:" << (void*)p << endl;
	}
	
	~STRING() {
		cout << "~STRING() - " << size << ", 번지:" << (void*)p << endl;
		delete[] p;
	}

	STRING(const STRING& other) : size{ other.size } {
		p = new char[size];

		// 깊은 복사
		memcpy(p, other.p, size);
		cout << "STRING 복사생성 - " << size << ", 번지:" << (void*)p << endl;
	}

	void show() {
		for (int i = 0; i < size; ++i) {
			cout << p[i];
		}

		cout << endl;
	}
};

//--------
int main()
//--------
{	
	// STRING의 생성자는 const char* 로 전달하고 처리하자. string 사용하지 말 것
	STRING s{ "난 STRING이야!" };
	STRING t = s;

	t.show();
	s.show();
	save("소스.cpp");
}

==================================================
소스.cpp2023-11-06 월요일 오후 7:03:53
==================================================
// 2023. 11. 6 월										(10주 1일)
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

using namespace std;
class STRING {
	size_t size;
	char* p;
public:

	STRING(const char* s) : size{strlen(s)} {
		p = new char[size];
		memcpy(p, s, size);

		cout << "STRING(const char*) - " << size << ", 번지:" << (void*)p << endl;
	}
	
	~STRING() {
		cout << "~STRING() - " << size << ", 번지:" << (void*)p << endl;
		delete[] p;
	}

	STRING(const STRING& other) : size{ other.size } {
		p = new char[size];

		// 깊은 복사
		memcpy(p, other.p, size);
		cout << "STRING 복사생성 - " << size << ", 번지:" << (void*)p << endl;
	}

	STRING& operator=(const STRING& other) {
		if (this == &other) {
			return *this;
		}

		delete[] p;
		size = other.size;
		p = new char[size];
		memcpy(p, other.p, size);

		cout << "STRING 복사할당연산자 - " << size << ", 번지:" << (void*)p << endl;
		return *this;
	}

	// C++11에서 도입한 이동생성과 이동할당을 코딩
	// && - r-vallue reference(이동문법지원과 완벽전달(perfect forwading))
	STRING(STRING&& other) : size{other.size} {
		p = other.p;

		// 만료(expired)될 객체 other를 초기화한다
		other.size = 0;
		other.p = nullptr;

		cout << "STRING 이동생성 - " << size << ", 번지:" << (void*)p << endl;

	}

	void show() {
		for (int i = 0; i < size; ++i) {
			cout << p[i];
		}
		cout << endl;
	}
};

//--------
int main()
//--------
{	
	STRING s{ "글자를 메모리에 저장하고 관리한다" };
	STRING t = move(s);		// 이동생성자를 코딩한다면 이동이 가능, 없으면 대신 복사생성

	cout << "s -";
	s.show();
	cout << "t -";
	t.show();
	save("소스.cpp");
}

==================================================
소스.cpp2023-11-08 수요일 오후 3:52:35
==================================================
// 2023. 11. 8 수										(10주 2일)
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------
// [과제] 나만의 자료형을 많이 만들고 반복 학습
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

using namespace std;
class STRING {
	size_t size;
	char* p;

public:

	STRING(const char* s) : size{strlen(s)} {
		p = new char[size];
		memcpy(p, s, size);

		cout << "STRING(const char*) - " << size << ", 번지:" << (void*)p << endl;
	}
	
	~STRING() {
		cout << "~STRING() - " << size << ", 번지:" << (void*)p << endl;
		delete[] p;
	}

	STRING(const STRING& other) : size{ other.size } {
		p = new char[size];

		// 깊은 복사
		memcpy(p, other.p, size);
		cout << "STRING 복사생성 - " << size << ", 번지:" << (void*)p << endl;
	}

	STRING& operator=(const STRING& other) {
		if (this == &other) {
			return *this;
		}

		delete[] p;
		size = other.size;
		p = new char[size];
		memcpy(p, other.p, size);

		cout << "STRING 복사할당연산자 - " << size << ", 번지:" << (void*)p << endl;
		return *this;
	}

	// C++11에서 도입한 이동생성과 이동할당을 코딩
	// && - r-vallue reference(이동문법지원과 완벽전달(perfect forwading))
	STRING(STRING&& other) : size{other.size} {
		p = other.p;

		// 만료(expired)될 객체 other를 초기화한다
		other.size = 0;
		other.p = nullptr;

		cout << "STRING 이동생성 - " << size << ", 번지:" << (void*)p << endl;

	}

	// 2023. 11. 8 move assignment operator
	STRING& operator=(STRING&& other) {
		if (this == &other) {
			return *this;
		}
		delete[] p;

		p = other.p;
		other.p = nullptr;
		other.size = 0;

		cout << "STRING 이동할당 - " << size << ", 번지:" << (void*)p << endl;
		return *this;

	}

	void show() {
		for (int i = 0; i < size; ++i) {
			cout << p[i];
		}
		cout << endl;
	}
};

//--------
int main()
//--------
{	
	STRING s{ "글자를 메모리에 저장하고 관리한다" };
	STRING t{ "나도 문자열을 관리하는 중" };

	cout << "s -";
	s.show();
	cout << "t -";
	t.show();

	t = move(s);		// move assignment(special 함수)가 호출되는 상황
						// move sementic에 미리 함수가 있으면 그 함수를 호출하고
						// 함수가 없다면 복사할당연사자를 대신 호출한다

	cout << "이미 만들어진 객체 T가 S의 자원을 이동하여 가져온다" << endl;

	cout << "s -";
	s.show();
	cout << "t -";
	t.show();

	save("소스.cpp");
}


==================================================
소스.cpp2023-11-13 월요일 오후 6:12:54
==================================================
// 2023. 11. 13 월										(11주 1일)
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------

#include <iostream>
#include "STRING.h"
#include "save.h"
using namespace std;

//--------
int main()
//--------
{

	STRING s{ "123" };

	s = s + "4567890";		// std::string은 POD 처럼 + 연산자를 사용한다
	cout << s;				// 화면 출력 - "1234567890"

	save("소스.cpp");
	save("STRING.cpp");
	save("STRING.h");
}

==================================================
STRING.cpp2023-11-13 월요일 오후 6:12:54
==================================================
//----------------------------------------------------------------------------------
// STRING.cpp - std::string과 비슷한 클래스
// 
// 2023. 11. 8 파일 분리
//----------------------------------------------------------------------------------
#include <iostream>
#include "STRING.h"

// 2023. 11. 13
bool STRING::관찰{false};		// 관찰하려면 어디선가 관찰을 true로 바꾸세요

// 2023. 11. 13 디폴트 생성자
STRING::STRING()
{
	if (관찰)
		std::cout << "STRING 디폴트 생성자 - " << size << ", 번지:" << (void*)p << std::endl;
}

STRING::STRING(const char* s) 
	: size{ std::strlen(s) }
{
	p = new char[size];
	std::memcpy(p, s, size);
	
	if (관찰)
		std::cout << "STRING(const char*) - " << size << ", 번지:" << (void*)p << std::endl;
}

STRING::~STRING() 
{
	if (관찰)
		std::cout << "~STRING() - " << size << ", 번지:" << (void*)p << std::endl;
	delete[] p;
}

STRING::STRING(const STRING& other) 
	: size{ other.size } 
{
	p = new char[size];

	// 깊은 복사
	memcpy(p, other.p, size);
	if (관찰)
		std::cout << "STRING 복사생성 - " << size << ", 번지:" << (void*)p << std::endl;
}

STRING& STRING::operator=(const STRING& other) 
{
	if (this == &other) {
		return *this;
	}

	delete[] p;

	size = other.size;
	p = new char[size];
	memcpy(p, other.p, size);

	if (관찰)
		std::cout << "STRING 복사할당연산자 - " << size << ", 번지:" << (void*)p << std::endl;
	return *this;
}

// C++11에서 도입한 이동생성과 이동할당을 코딩
// && - r-vallue reference(이동문법지원과 완벽전달(perfect forwading))
STRING::STRING(STRING&& other) : size{ other.size } 
{
	p = other.p;

	// 만료(expired)될 객체 other를 초기화한다
	other.size = 0;
	other.p = nullptr;

	std::cout << "STRING 이동생성 - " << size << ", 번지:" << (void*)p << std::endl;

}

// 2023. 11. 8 move assignment operator
STRING& STRING::operator=(STRING&& other)
{
	if (this == &other) {
		return *this;
	}
	delete[] p;

	size = other.size;
	p = other.p;
 
	other.p = nullptr;
	other.size = 0;

	std::cout << "STRING 이동할당 - " << size << ", 번지:" << (void*)p << std::endl;
	return *this;

}

STRING STRING::operator+(const char* s) const
{
	STRING temp;

	temp.size = size + strlen(s);
	temp.p = new char[temp.size];

	memcpy(temp.p, p, size);
	memcpy(temp.p + size, s, strlen(s));

	return temp;
}

void STRING::show() const
{
	for (int i = 0; i < size; ++i) {
		std::cout << p[i];
	}
	std::cout << std::endl;
}

std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i = 0; i < s.size; ++i) {
		os << s.p[i];
	}

	return os;
}


==================================================
STRING.h2023-11-13 월요일 오후 6:12:54
==================================================
//----------------------------------------------------------------------------------
// STRING.h - std::string과 비슷한 클래스
// 
// 2023. 11. 8 파일 분리
// 2023. 11. 13 원할때만 관찰할 수 있게 Flag 처리
//----------------------------------------------------------------------------------
#pragma once

class STRING {
	size_t size{};
	char* p{};
	
public:
	// 2023. 11. 13
	static bool 관찰;					// 클래스 로컬 맴버이면서 전역변수 취급

public:
	// 2023. 11. 13 디폴트 생성자
	STRING();							// special funtion	
	STRING(const char*);
	~STRING();							// special funtion

	// 복사생성
	STRING(const STRING&);				// special funtion
	STRING& operator=(const STRING&);	// special funtion

	// 이동생성
	STRING(STRING&& other);				// special funtion
	STRING& operator=(STRING&&);		// special funtion
	
	// 2023. 11. 13 연산자 오버로딩
	STRING operator+(const char*) const;
	friend std::ostream& operator<<(std::ostream&, const STRING&);

	void show() const;
};


==================================================
소스.cpp2023-11-13 월요일 오후 6:33:43
==================================================
// 2023. 11. 13 월										(11주 1일)
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------

#include <iostream>
#include "STRING.h"
#include "save.h"
using namespace std;

//--------
int main()
//--------
{

	STRING s{ "123" };

	s = s + "4567890";		// std::string은 POD 처럼 + 연산자를 사용한다
	cout << s;				// 화면 출력 - "1234567890"

	// 컴파일러는 연산자 오버로딩을 해결하기 위해
	// lhs  operator기호  rhs 
	// 1. lhs의 맴버함수로 operator기호(rhs) 함수가 있는지 찾음
	// 2. operator기호(lhs, rhs)인 전역함수가 있나 찾음
	

	save("소스.cpp");
	save("STRING.cpp");
	save("STRING.h");
}


==================================================
소스.cpp2023-11-13 월요일 오후 6:54:55
==================================================
// 2023. 11. 13 월										(11주 1일)
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------

#include <iostream>
#include "STRING.h"
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	STRING s{ "12345" };

	for (int i = 0; i < s.length(); ++i) {
		cout << s[i] << endl;
		//cout << s.operator[](i) << endl;
	}

	save("소스.cpp");
}

==================================================
소스.cpp2023-11-13 월요일 오후 7:02:59
==================================================
// 2023. 11. 13 월										(11주 1일)
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------

#include <iostream>
#include "STRING.h"
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	STRING s{ "C++ Programming Language - Operator Overloading" };

	// [문제] s의 문자열을 오름차순으로 정렬하라

	qsort(&s[0], s.length(), sizeof(char), [](const void* a, const void* b) {
		return *(char*)a - *(char*)b;
		});

	cout << s << endl;
	
	save("소스.cpp");
}

==================================================
소스.cpp2023-11-15 수요일 오후 3:57:59
==================================================
// 2023. 11. 15 목										(11주 2일)
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------

#include <iostream>
#include "STRING.h"
#include "save.h"
using namespace std;




//--------
int main()
//--------
{
	STRING::관찰 = true;
	STRING s{ "C++ Programming" };

	s = "학생을 쳐다보지 않는다 " + s;
	// 1. 왼쪽 피연산자의 맴버로 .operator+(s)가 있나 찾음
	// 2. 전역함수를 찾음 operator+( const char*, STRING )


	cout << s << endl;

	save("소스.cpp");
}


==================================================
소스.cpp2023-11-15 수요일 오후 4:22:15
==================================================
// 2023. 11. 15 목										(11주 2일)
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------

#include <iostream>
#include "STRING.h"
#include <algorithm>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	STRING s[5]{ "333", "1", "55555", "4444", "22" };
	
	// [문제] "122333444455555" 를 만들어라
	// s를 모두 더한 temp를 만들어라

	qsort(s, sizeof(s) / sizeof(STRING), sizeof(STRING), [](const void* a, const void* b) {
		return static_cast<int>(((STRING*)a)->length() - ((STRING*)b)->length());		// return 값이 양수면 위치를 바꿈
		});

	STRING temp;
	for (const STRING& s : s) {
		temp = temp + s;
	}

	cout << temp << endl;

	save("소스.cpp");
}


==================================================
소스.cpp2023-11-15 수요일 오후 5:14:18
==================================================
// 2023. 11. 15 목										(11주 2일)
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------
#include <iostream>
#include "STRING.h"
#include "save.h"
using namespace std;

class INT {
	int n;

public:
	INT() {}					// 생성자를 하나라도 코딩했다면 special 함수인 default ctor를 코딩함
	INT(int i) : n{ i } {
	}

	INT& operator++() {			// pre-increment
		++n;
		return *this;
	}

	INT operator++(int) {		// post-increment
		INT temp{ *this };
		++(*this);
		return temp;
	}
	
	friend ostream& operator<<(ostream& os, INT i) {
		return os << i.n;
	}
};

//--------
int main()
//--------
{
	INT n{ 100 };

	INT k = ++n;
	INT x = n++;		// INT.operator++(int);
	
	cout << k << endl;
	cout << x << endl;

	save("소스.cpp");
}


==================================================
소스.cpp2023-11-20 월요일 오후 5:53:57
==================================================
// 2023. 11. 20 월										(12주 1일)
//---------------------------------------------------------------------------
// class
//---------------------------------------------------------------------------

#include <iostream>
#include "STRING.h"
#include <algorithm>
#include "save.h"
using namespace std;

void f(int);

void f(int n) {
	cout << "인자" << n << "을 전달받았습니다" << endl;
}

//--------
int main()
//--------
{
	(*f)(3);		// 함수 이름 자체는 주소이기 때문에 이렇게 코딩 가능

	//auto x = f;

	//x(100);

	// int a[10]
	
	void (*x)(int) = f;		// 함수를 함수포인터로 저장가능

	cout << sizeof(x) << endl;
	cout << typeid(x).name() << endl;

	save("소스.cpp");
}


==================================================
소스.cpp2023-11-20 월요일 오후 6:11:20
// 2023. 11. 20 월										(12주 1일)
//---------------------------------------------------------------------------
// class
// 2023. 12. 13 기말시험
//---------------------------------------------------------------------------

#include <iostream>
#include "STRING.h"
#include <algorithm>
#include "save.h"
using namespace std;

// 호출할 수(callable) 있는 것은 함수뿐이 아니다
// 1. 함수
// 2. 함수를 가리키는 포인터를 호출할 수 있다
// 3. () 연산자를 오버로딩한 객체를 호출할 수 있다 - function object

// Callable Type - 호출가능한 타입

// Dog가 ()연산자를 오버로딩 - () - function call operator
class Dog {
public:
	void operator+(int a) {
	}
	void operator()(int n) {
		cout << n << "을 받았습니다" << endl;
	}
};

//--------
int main()
//--------
{
	//int (*f)() = main;
	//cout << "메인" << endl;
	//f();

	Dog dog;
	dog(333);		// dog.operator()(333);

	save("소스.cpp");
}


==================================================
소스.cpp2023-11-20 월요일 오후 6:18:09
==================================================
// 2023. 11. 20 월										(12주 1일)
//---------------------------------------------------------------------------
// class
// 2023. 12. 13 기말시험
//---------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

// 호출할 수(callable) 있는 것은 함수뿐이 아니다
// 1. 함수
// 2. 이름없는 함수 람다
// 3. 함수를 가리키는 포인터를 호출할 수 있다
// 4. () 연산자를 오버로딩한 객체를 호출할 수 있다 - function object

// Callable Type - 호출가능한 타입

// Dog가 ()연산자를 오버로딩 - () - function call operator

//--------
int main()
//--------
{
	int a[]{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };
	
	class Dog {
	public:
		int operator()(int a, int b) {
			return a < b;
		}
	};

	Dog dog;

	// C++에서 정렬
	sort(begin(a), end(a), dog);

	for (int i : a) {
		cout << i << " ";
	}
	cout << endl;

	save("소스.cpp");
}


==================================================
소스.cpp2023-11-20 월요일 오후 6:38:04
==================================================
// 2023. 11. 20 월										(12주 1일)
//---------------------------------------------------------------------------
// class
// 2023. 12. 13 기말시험
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "STRING.h"
using namespace std;

// OOP
// 1. Information Hiding - private
// 2. Inheritance - code reuse
// 3. Polymorphism - 다형성 - { static } - binding
//							 { dynamic }
//--------
int main()
//--------
{
	save("소스.cpp");
}


==================================================
소스.cpp2023-11-20 월요일 오후 6:51:37
==================================================
// 2023. 11. 20 월										(12주 1일)
//---------------------------------------------------------------------------
// class
// 2023. 12. 13 기말시험
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <fstream>
#include "save.h"
#include "STRING.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution uid{ 1, 100 };

int gn{ 0 };

class Dog {
private:
	string name;
	int age;

public:
	Dog(){			// 이 함수는 자동으로 inline화
		age = uid(dre);
		name = "댕댕-" + to_string(++gn) + "호";
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		os << "나이 - " << dog.age << ", 이름 - " << dog.name;
		return os;
	}
};

//--------
int main()
//--------
{
	Dog dogs[20];		// 이름과 나이는 랜덤으로

	ofstream out{ "개20마리.txt" };

	for (const Dog& dog : dogs) {
		out << dog << endl;
	}


	save("소스.cpp");
}


==================================================
소스.cpp2023-11-22 수요일 오후 3:51:29
==================================================
// 2023. 11. 22 수										(12주 2일)
//---------------------------------------------------------------------------
// class
// 2023. 12. 11 월(15주 1일) - 한학기 정리, 책 소개
// 2023. 12. 13 수(15주 2일) - 기말시험
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <fstream>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] "개20마리.txt" 에는 class Dog 객체 20개의 정보가 기록되어 있다
// class Dog{
//		int age;
//		string name;
// 맴버 변수가 있으며
//
//		friend ostream& operator<<(ostream& os, const Dog& dog){
//		return os << dog.age << "\t" << dog.name << "\t";
//		}
// };
// 연산자 << 를 오버로딩하여 파일에 기록하였다
//
// 20마리 정보를 읽어 나이오름차순으로 정렬하여 출력하라

class Dog {
	int age;
	string name;

public:

	// special 함수를 코딩할 이유가 전혀 없음

	int getAge() const {
		return age;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.age << "\t" << dog.name << "\t";
	}
	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.age >> dog.name;
	}

};

//--------
int main()
//--------
{
	ifstream in{ "개20마리.txt" };
	if (!in) {
		cout << "파일을 읽지 못했다" << endl;
		return 0;
	}

	Dog dogs[20];
	
	for (int i = 0; i < 20; ++i) {
		in >> dogs[i];
	}

	qsort(dogs, sizeof(dogs) / sizeof(Dog), sizeof(Dog), [](const void* a, const void* b) {
		return ((Dog*)a)->getAge() - ((Dog*)b)->getAge();
		});

	cout << "나이 (ascending order)순으로 정렬한 결과" << endl;

	for (const Dog& dog : dogs) {		// const & 꼭 붙일것
		cout << dog << endl;
	}

	save("소스.cpp");
}


==================================================
소스.cpp2023-11-22 수요일 오후 4:07:30
==================================================
// 2023. 11. 22 수										(12주 2일)
//---------------------------------------------------------------------------
// class
// 2023. 12. 11 월(15주 1일) - 한학기 정리, 책 소개
// 2023. 12. 13 수(15주 2일) - 기말시험
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
#include "STRING.h"
using namespace std;

class X {
private:
	// data member;
public:
	// function member;
	// 1. special member;
	// 2. opreator overloading;
	// 3. getter/setter interface;
	// 4. friend (>>, <<)

	// 자원을 관리(RAII)
	// 소멸자에서 해제를 해줘야함
	// smart*를 사용했으면 special function을 반드시 코딩해야함
};

//--------
int main()
//--------
{

	// X a;			// a를 instancing, Data(전역에 정의시)
	// {X  a;}		// Stack
	// X* a = new X;	// Free Store
	
	save("소스.cpp");
}


==================================================
소스.cpp2023-11-22 수요일 오후 5:19:28
==================================================
// 2023. 11. 22 수										(12주 2일)
//---------------------------------------------------------------------------
// class
// 2023. 12. 11 월(15주 1일) - 한학기 정리, 책 소개
// 2023. 12. 13 수(15주 2일) - 기말시험
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
#include "STRING.h"
using namespace std;

// 상속(Inheritance)
// 1. 코드 재사용
// 2. 다형성 구현 - One interface, multiple method(behavior)

// 상속 연습 동물 개 새를 상속계층(hierarchy)으로 만들어 본다

class Animal {
	int age{ 0 };

public:
	Animal() {
		cout << "Animal의 기본생성자" << endl;
	}

	Animal(int n) : age{ n } {

	}

	~Animal() {
		cout << "Animal의 소멸자" << endl;
	}
	void move() const {
		cout << "동물 움직인다 - " << age << endl;
	}

};

class Dog : public Animal {
	bool bite{ false };

public:
	Dog() {
		cout << "Dog의 기본생성자" << endl;
	}

	Dog(int n) : Animal(n) {

	}

	~Dog() {
		cout << "Dog의 소멸자" << endl;
	}
};

//--------
int main()
//--------
{
	cout << "부모 animal의 크기 - " << sizeof(Animal) << endl;
	cout << "자식 Dog의 크기 - " << sizeof(Dog) << endl;
	
	// 자식 객체의 메모리 속에는 부모 객체의 메모리가 항상 포함되어 있음

	Dog dog{ 10 };	// 10을 생성자에서 처리
	
	Dog dog{ 10 };
	
	// [문제 1] dog의 메모리를 관찰하자
	cout << "Dog의 메모리 크기 : " << sizeof(dog) << endl;

	// [문제 2] 생성자와 소멸자의 호출을 관찰하자
	dog.move();

	// [문제 3] Dog의 나이를 설정하자

	save("소스.cpp");
}


==================================================
소스.cpp2023-11-27 월요일 오후 6:02:43
==================================================
// 2023. 11. 27 월										(13주 1일)
//---------------------------------------------------------------------------
// class
// 2023. 12. 11 월(15주 1일) - 한학기 정리, 책 소개
// 2023. 12. 13 수(15주 2일) - 기말시험
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
#include "STRING.h"
using namespace std;

// 상속(Inheritance)
// 1. 코드 재사용
// 2. 다형성 구현 - One interface, multiple method(behavior)

// 상속 연습 동물 개 새를 상속계층(hierarchy)으로 만들어 본다

class Animal {
	int age{ 0 };

public:
	Animal() {
		cout << "Animal의 기본생성자" << endl;
	}

	Animal(int n) : age{ n } {
		cout << "Animal의 생성자" << endl;

	}

	~Animal() {
		cout << "Animal의 소멸자" << endl;
	}
	void move() const {
		cout << "동물 움직인다 - " << age << endl;
	}

};

class Dog : public Animal {
	bool bite{ false };

public:
	Dog() {
		cout << "Dog의 기본생성자" << endl;
	}

	Dog(int n) : Animal(n) {
		cout << "Dog의 생성자" << endl;

	}

	~Dog() {
		cout << "Dog의 소멸자" << endl;
	}
};

//--------
int main()
//--------
{
	// 부모와 자식간의 관계
	Animal a;
	Dog d;

	// a = d;		// 언제나 성립 - Object slicing
	// d = a;		// 성립 불가 -> 작은 메모리를 큰 메모리로 만들 방법은 없음

	// 그런데 이와 같이 객체를 직접 대입하는 문장은 실용성이 없음

	Animal* pa = &a;
	Dog* pd = &d;

	// 조상의 *는 언제나 자식 객체를 pointing 할 수 있음 - dynamic_casting
	pa = pd;		// up-casting은 언제나 성립, 상속계층도의 화살표 방향과 같음
	//pd = pa;		// down-casting -> 조건부로 성립가능

	save("소스.cpp");
}


==================================================
소스.cpp2023-11-27 월요일 오후 6:52:07
==================================================
// 2023. 11. 27 월										(13주 1일)
//---------------------------------------------------------------------------
// class
// 2023. 12. 11 월(15주 1일) - 한학기 정리, 책 소개
// 2023. 12. 13 수(15주 2일) - 기말시험
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
#include "STRING.h"
using namespace std;

// [상속 연습] 동물 개 새를 상속계층(hirearchy)으로 만들어라
// C++에서 다형성을 구현하는 핵심키워드 - virtual
// 어떤 클래스가 virtual 맴버를 만들면 자식 클래스의 같은 맴버는 자동으로 virtual으로 변환됨
// 전부 virtual, override을 명시적으로 붙여줘서 가독성을 높임
// final을 붙이면 더 이상 자식 클래스를 만들어도 override 금지

class Animal {
	int age;
public:
	virtual void move() const {
		cout << "동물 - 움직인다" << endl;
	}
};

class Dog : public Animal{
	bool bite;
public:
	virtual void move() const override {		// 조상의 맴버를 overriding 함
		cout << "개 - 달린다" << endl;
	}
};

class Bird : public Animal {
	long long fly;
public:
	virtual void move() const override final {
		cout << "새 - 난다" << endl;
	}
};

//--------
int main()
//--------
{
	// 다형성이라는 유연성을 구현하려면 메모리를 더 사용한다
	// 핵심 키워드는 virtual

	cout << "virtual 멤버가 있는 Dog의 크기 - " << sizeof(Dog) << endl;

	Dog d;
	Bird b;

	Animal* p = &d;
	p->move();

	p = &b;
	p->move();

	save("소스.cpp");
}


==================================================
소스.cpp2023-11-29 수요일 오후 3:40:30
==================================================
// 2023. 11. 29 수										(13주 2일)
//---------------------------------------------------------------------------
// class
// 2023. 12. 11 월(15주 1일) - 한학기 정리, 책 소개
// 2023. 12. 13 수(15주 2일) - 기말시험
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
#include "STRING.h"
using namespace std;

// [상속 연습] 동물 개 새를 상속계층(hirearchy)으로 만들어라
// C++에서 다형성을 구현하는 핵심키워드 - virtual
// 어떤 클래스가 virtual 맴버를 만들면 자식 클래스의 같은 맴버는 자동으로 virtual으로 변환됨
// 전부 virtual, override을 명시적으로 붙여줘서 가독성을 높임
// final을 붙이면 더 이상 자식 클래스를 만들어도 override 금지

class Animal {
public:
	virtual void move() const {
		cout << "동물 - 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	virtual void move() const override {		// 조상의 맴버를 overriding 함
		cout << "개 - 달린다" << endl;
	}
};

class Bird : public Animal {
public:
	virtual void move() const override final {
		cout << "새 - 난다" << endl;
	}
};

// [문제] 동물 10마리를 관리하는 코드를 만든다
// 랜덤값에 따라 홀수면 Dog, 짝수면 Bird를 생성하라
// 모든 동물의 move()를 호출하여 다형성이 구현됨을 확인하라

default_random_engine dre;
uniform_int_distribution uid{ 0, 1 };

//--------
int main()
//--------
{
	Animal* animals[10];
	for (Animal*& p : animals) {
		if (uid(dre)) {
			p = new Dog;
		}
		else {
			p = new Bird;
		}
	}

	for (int i = 0; i < 10; ++i) {
		if (uid(dre)) {
			animals[i] = new Dog;
		}
		else {
			animals[i] = new Bird;
		}
	}

	for (int i = 0; i < 10; ++i) {
		animals[i]->move();
	}

	for (Animal*& p : animals) {
		delete p;
	}
	save("소스.cpp");
}


==================================================
소스.cpp2023-11-29 수요일 오후 3:41:50
==================================================
// 2023. 11. 29 수										(13주 2일)
//---------------------------------------------------------------------------
// class
// 2023. 12. 11 월(15주 1일) - 한학기 정리, 책 소개
// 2023. 12. 13 수(15주 2일) - 기말시험
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
#include "STRING.h"
using namespace std;

// [상속 연습] 동물 개 새를 상속계층(hirearchy)으로 만들어라
// C++에서 다형성을 구현하는 핵심키워드 - virtual
// 어떤 클래스가 virtual 맴버를 만들면 자식 클래스의 같은 맴버는 자동으로 virtual으로 변환됨
// 전부 virtual, override을 명시적으로 붙여줘서 가독성을 높임
// final을 붙이면 더 이상 자식 클래스를 만들어도 override 금지

class Animal {
public:
	virtual void move() const {
		cout << "동물 - 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	virtual void move() const override {		// 조상의 맴버를 overriding 함
		cout << "개 - 달린다" << endl;
	}
};

class Bird : public Animal {
public:
	virtual void move() const override final {
		cout << "새 - 난다" << endl;
	}
};

// [문제] 동물 10마리를 관리하는 코드를 만든다
// 랜덤값에 따라 홀수면 Dog, 짝수면 Bird를 생성하라
// 모든 동물의 move()를 호출하여 다형성이 구현됨을 확인하라

default_random_engine dre;
uniform_int_distribution uid{ 0, 1 };

//--------
int main()
//--------
{
	Animal* animals[10];
	for (Animal*& p : animals) {
		if (uid(dre)) {
			p = new Dog;
		}
		else {
			p = new Bird;
		}
	}

	for (Animal* p : animals) {
		p->move();
	}

	for (Animal*& p : animals) {
		delete p;
	}
	save("소스.cpp");
}


==================================================
소스.cpp2023-11-29 수요일 오후 4:11:47
==================================================
// 2023. 11. 29 수										(13주 2일)
//---------------------------------------------------------------------------
// class
// 2023. 12. 11 월(15주 1일) - 한학기 정리, 책 소개
// 2023. 12. 13 수(15주 2일) - 기말시험
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
#include "STRING.h"
using namespace std;

// [상속 연습] 동물 개 새를 상속계층(hirearchy)으로 만들어라
// C++에서 다형성을 구현하는 핵심키워드 - virtual
// 어떤 클래스가 virtual 맴버를 만들면 자식 클래스의 같은 맴버는 자동으로 virtual으로 변환됨
// 전부 virtual, override을 명시적으로 붙여줘서 가독성을 높임
// final을 붙이면 더 이상 자식 클래스를 만들어도 override 금지

class Animal {
public:
	virtual void move() const {
		cout << "동물 - 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	virtual void move() const override {		// 조상의 맴버를 overriding 함
		cout << "개 - 달린다" << endl;
	}
};

class Bird : public Animal {
public:
	virtual void move() const override final {
		cout << "새 - 난다" << endl;
	}
};

// [문제] 동물을 관리하는 코드를 만든다
// 몇 마리를 관리할 지는 사용자 입력에 따른다
// 랜덤값에 따라 홀수면 Dog, 짝수면 Bird를 생성하라
// 모든 동물의 move()를 호출하여 다형성이 구현됨을 확인하라
// 이 과정이 영원히 반복시행 되도록 관리하라

random_device rd;
default_random_engine dre{ rd() };
uniform_int_distribution uid{ 0, 1 };

//--------
int main()
//--------
{
	save("소스.cpp");

	while (true) {
		cout << "몇 마리를 원하나요? ";
		int num;
		cin >> num;		// run-time에 결정

		Animal** animals;
		animals= new Animal * [num];		// run-time에 num이 결정되기 때문에 range for 문은 사용할 수 없음

		for (int i = 0; i < num; ++i) {
			if (uid(dre)) {
				animals[i] = new Dog;
			}
			else {
				animals[i] = new Bird;
			}
		}

		for (int i = 0; i < num; ++i) {
			animals[i]->move();
		}

		for (int i = 0; i < num; ++i) {
			delete[] animals[i];
		}

		delete[] animals;
	}
}


==================================================
소스.cpp2023-11-29 수요일 오후 4:36:35
==================================================
// 2023. 11. 29 수										(13주 2일)
//---------------------------------------------------------------------------
// class
// 2023. 12. 11 월(15주 1일) - 한학기 정리, 책 소개
// 2023. 12. 13 수(15주 2일) - 기말시험
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
#include "STRING.h"
using namespace std;

// [상속 연습] 동물 개 새를 상속계층(hirearchy)으로 만들어라
// C++에서 다형성을 구현하는 핵심키워드 - virtual
// 어떤 클래스가 virtual 맴버를 만들면 자식 클래스의 같은 맴버는 자동으로 virtual으로 변환됨
// 전부 virtual, override을 명시적으로 붙여줘서 가독성을 높임
// final을 붙이면 더 이상 자식 클래스를 만들어도 override 금지


// Animal은 모든 동물의 공통점을 표현한 abstract 클래스가 되는 것이 바람직함
// 어떤 클래스가 한 개 이상의 순수가상함수(pure virtual function)가 있다면
// 그 클래스는 추상 클래스가 되고 객체를 만들 수 없게 됨
// Pure virtual function은 함수의 몸체가 없는 함수임
class Animal {
	int a;
public:
	virtual void move() const = 0;		// move는 function body가 없는 순수가상함수 -> (함수 = 0;)으로 표현함
};

class Dog : public Animal {
public:
	virtual void move() const override {		// 조상의 맴버를 overriding 함
		cout << "개 - 달린다" << endl;
	}
};

class Bird : public Animal {
public:
	virtual void move() const override final {
		cout << "새 - 난다" << endl;
	}
};
// [문제] 동물을 관리하는 코드를 만든다
// 몇 마리를 관리할 지는 사용자 입력에 따른다
// 랜덤값에 따라 홀수면 Dog, 짝수면 Bird를 생성하라
// 모든 동물의 move()를 호출하여 다형성이 구현됨을 확인하라
// 이 과정이 영원히 반복시행 되도록 관리하라
// Bird인 경우에만 move()를 호출하고 싶다

// 다음시간 - 동적관리예제 abstract, pure virtual
// dyanmic_cast 까지

random_device rd;
default_random_engine dre{ rd() };
uniform_int_distribution uid{ 0, 1 };

//--------
int main()
//--------
{
	save("소스.cpp");

	while (true) {
		cout << "몇 마리를 원하나요? ";
		int num;
		cin >> num;		// run-time에 결정

		Animal** animals;
		animals= new Animal * [num];		// run-time에 num이 결정되기 때문에 range for 문은 사용할 수 없음

		for (int i = 0; i < num; ++i) {
			if (uid(dre)) {
				animals[i] = new Dog;
			}
			else {
				animals[i] = new Bird;
			}
		}

		// 원래 Bird인 경우에만 move()
		// RTTI(Real_Time Type Identification)

		for (int i = 0; i < num; ++i) {
			if (dynamic_cast<Bird*>(animals[i]) != nullptr) {
				animals[i]->move();
			}
		}

		for (int i = 0; i < num; ++i) {
			delete[] animals[i];
		}

		delete[] animals;
	}
}
