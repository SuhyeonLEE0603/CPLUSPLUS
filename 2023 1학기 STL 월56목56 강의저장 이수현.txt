==================================================
소스.cpp 2023-03-06 월요일 오후 1:48:27
==================================================
// 2023. 3. 2 목56										(1주 1일)
//---------------------------------------------------------------------------
// 한학기 강의를 파일에 저장할 수 있는 코딩을 한다.(강의저장파일 만들기)
// save() 함수를 save.h 와 save.cpp로 분리 할 수 있다.
//---------------------------------------------------------------------------
// VS 설정 : Release/x64, Project 설정 : C++언어 latest, C++ SDL 검사/아니오
//---------------------------------------------------------------------------
//
// c++ 참고 사이트 : cppreference.com

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	std::cout << "2023 STL 강의 시작합니다" << '\n';
	save("save.h");
	save("save.cpp");
	save("소스.cpp");
}

==================================================
save.h 2023-03-06 월요일 오후 1:49:32
==================================================
//-----------------------------------
// save.h 한학기 강의를 저장하는 함수
//-----------------------------------

#ifndef MY_SAVE
#define MY_SAVE

#include <string>

void save(const std::string&);

#endif 

==================================================
save.cpp 2023-03-06 월요일 오후 1:49:32
==================================================

//-----------------------------------
// save.h 한학기 강의를 저장하는 함수
//-----------------------------------

#include "save.h"
#include <fstream>
#include <chrono>

//------------------------------------
void save(const std::string& fileName)
//------------------------------------
{
	// fileName을 읽기 모드로 연다
	std::ifstream in{ fileName };

	// 저장할 파일을 덧붙여쓰기 모드로 연다
	std::ofstream out{ "2023 1학기 STL 월56목56 강의저장.txt", std::ios::app };

	// 저장한 시간을 파일에 기록한다.
	auto now = std::chrono::system_clock::now();				// time_point를 얻는다
	auto time = std::chrono::system_clock::to_time_t(now);	// UTC 시간으로 변환
	auto lt = localtime(&time);									// 현지 시간으로 변환
	auto old = out.imbue(std::locale("ko_KR"));					// 한국으로 변경

	// 시간 출력
	out << '\n' << '\n';

	out << "==================================================" << '\n';
	out << fileName << std::put_time(lt, "%x %A %X") << '\n';
	out << "==================================================" << '\n';

	out.imbue(old);												// 원래로 복귀

	// fileName을 읽어 저장파일에 덧붙여 쓴다 (STL 자료구조와 알고리즘)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ out });
}

==================================================
소스.cpp 2023-03-06 월요일 오후 1:49:32
==================================================
// 2023. 3. 2 목56										(1주 1일)
//---------------------------------------------------------------------------
// 한학기 강의를 파일에 저장할 수 있는 코딩을 한다.(강의저장파일 만들기)
// save() 함수를 save.h 와 save.cpp로 분리 할 수 있다.
//---------------------------------------------------------------------------
// VS 설정 : Release/x64, Project 설정 : C++언어 latest, C++ SDL 검사/아니오
//---------------------------------------------------------------------------
//
// c++ 참고 사이트 : cppreference.com

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	std::cout << "2023 STL 강의 시작합니다" << '\n';
	save("save.h");
	save("save.cpp");
	save("소스.cpp");
}



==================================================
소스.cpp 2023-03-06 월요일 오후 2:11:40
==================================================
// 2023. 3. 6 월										(1주 2일)
//---------------------------------------------------------------------------
// 한학기 강의를 파일에 저장할 수 있는 코딩을 한다.(강의저장파일 만들기)
// save() 함수를 save.h 와 save.cpp로 분리 할 수 있다.
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void change(int&, int&);

//--------
int main()
//--------
{
	// [문제] main()이 의도한대로 실행되게 필요한 코딩을 하라
	// main()이 수정되면 안됨
	int a{ 1 }, b{ 2 };

	change(a, b);
	cout << a << ", " << b << endl; // 2, 1

	save("소스.cpp");
}
// &는 기존 변수에 대한 참조를 만들어 줌
// -> 인자를 받을 때 변수가 복사되어 인자로 받는 것이 아닌 원본 변수를 참조하게 됨
void change(int &a, int &b) {		
	int tmp{ a };
	a = b;
	b = tmp;
}

==================================================
소스.cpp 2023-03-06 월요일 오후 3:03:30
==================================================
// 2023. 3. 6 월										(1주 2일)
//---------------------------------------------------------------------------
// C++ programming paradigm
// 1. Procedual PL (절차지향)
// 2. Object Oriented PL (객채지향)
// 3. Generic PL (자료형에 무관한)(STL 수업)
//   -> template -> 함수 -> 알고리즘
//               -> 클래스 -> 자료구조
// 4. Template Meta PL
// 5. Functional PL
#include <iostream>
#include "save.h"
using namespace std;


class Dog {
private:
	int n;
public:
	Dog(int n) : n{ n } {}			// 초기화 리스트는 생성자의 몸체보다 먼저 실행, 맴버 변수들의 초기화를 목적으로 사용
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.n;
	}
};

void change(int&, int&);
void change(Dog&, Dog&);
template<class T>
void change(T& a, T& b) {
	T temp{ a };
	a = b;
	b = temp;
}
//--------
int main()
//--------
{
	
	Dog a{ 1 }, b{ 2 };

	change(a, b);
	cout << a << ", " << b << endl; // 2, 1

	save("소스.cpp");
}

void change(int &a, int &b) {
	int temp{ a };
	a = b;
	b = temp;
}

void change(Dog& a, Dog& b) {
	Dog temp{ a };
	a.operator=(b);
	b = temp;
}

==================================================
소스.cpp 2023-03-06 월요일 오후 3:20:12
==================================================
// 2023. 3. 6 월										(1주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 int
//===========================================================================
#include <iostream>
#include <random>
#include <format>
#include "save.h"
using namespace std;


default_random_engine dre;
//--------
int main()
//--------
{
	// 랜덤 int 1000개를 생성해서 화면에 출력하라
	uniform_int_distribution<int> uid{ 0, 999999999 };

	//[문제] 1000개 중에서 가장 큰 수를 출력하라
	for (int i{}; i < 1000; ++i) 
		cout << format("{:10}",uid(dre));
	cout << endl;
	save("소스.cpp");
}


==================================================
소스.cpp 2023-03-09 목요일 오후 1:42:42 
==================================================
// 2023. 3. 9 목										(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 int
//===========================================================================
#include <iostream>
#include <random>
#include <format>
#include <numeric>
#include "save.h"
using namespace std;


default_random_engine dre;
//--------
int main()
//--------
{
	// 랜덤 int 1000개를 생성해서 화면에 출력하라
	uniform_int_distribution<int> uid{ 0, 10'000 };

	//[문제] 1000개 중에서 가장 큰 수를 출력하라
	int maxValue = numeric_limits<int>::min();
	cout << "int의 최솟값은 - " << maxValue << endl;
	for (int i{}; i < 1000; ++i){
		int n = uid(dre);
		if (maxValue < n) 
			maxValue = n;
		cout << format("{:10}", n);
	}
	cout << endl;
	cout << "최댓값 - " << maxValue << endl;
	save("소스.cpp");
}

==================================================
소스.cpp 2023-03-09 목요일 오후 2:07:35 
==================================================
// 2023. 3. 9 목										(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 int
//===========================================================================
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

//[문제] 파일 "int 천개"에는 int값 1000개가 저장되어 있다.
// int는 값이 text로 저장되었으며 값과 값 사이에는 공백이 있다.
// 파일을 읽어 int값 1000개를 화면에 출력하라.

//--------
int main()
//--------
{


	ifstream in{ "int 1000개" };			// RAll 선언과 동시에 초기화기법

	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;						// exit( 0 ); 동일 - 찾아보기
	}

	int n;
	for (int i{}; i < 1'000; ++i) {
		in >> n;
		cout << n << " ";
	}
	save("소스.cpp");
}

==================================================
소스.cpp 2023-03-09 목요일 오후 2:16:19 
==================================================
// 2023. 3. 9 목										(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 int
//===========================================================================
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

//[문제] 파일 "int 천개"에는 몇 개인지 모르는 int값이 저장되어 있다.
// int는 값이 text로 저장되었으며 값과 값 사이에는 공백이 있다.
// 파일을 읽어 int값 1000개를 화면에 출력하라.

//--------
int main()
//--------
{


	ifstream in{ "int 1000개" };			// RAll 선언과 동시에 초기화기법

	// coding convention
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;						// exit( 0 ); 동일 - 찾아보기
	}

	int n;
	int cnt{};
	while (in >> n) {
		cout << n << " ";
		++cnt;
	}
	cout << "모두" << cnt << "개 int를 읽었다." << endl;

	save("소스.cpp");
}

==================================================
소스.cpp 2023-03-09 목요일 오후 2:44:45 
==================================================
// 2023. 3. 9 목										(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 int
//===========================================================================
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

//[문제] 파일 "int 천개"에는 몇 개인지 모르는 int값이 저장되어 있다.
// int는 값이 text로 저장되었으며 값과 값 사이에는 공백이 있다.
// 파일을 읽어 int값 1000개를 메모리에 저장하라.

//--------
int main()
//--------
{
	ifstream in{ "int 1000개" };			// RAll 선언과 동시에 초기화기법
	
	int a[1'000];						// contiguous memory -> 공간의 메모리 연속, 효율이 좋음
										// continuous memory -> 시간의 메모리 연속
	for (int i{}; i < 1'000; ++i)
		in >> a[i];
	
	// 가장 큰 값을 찾아 화면에 출력하라.
	int maxValue = a[0];

	for (int n : a) {					// a에 있는 모든 요소를 차례로 n 변수에 대입하며 반복		
		if (maxValue < n) {
			maxValue = n;
		}
	}
	cout << "최댓값 -" << maxValue << endl;
	save("소스.cpp");
}


==================================================
소스.cpp 2023-03-09 목요일 오후 2:53:15 
==================================================
// 2023. 3. 9 목										(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 int
//===========================================================================
#include <iostream>
#include <fstream>
#include <random>
#include <algorithm>
#include <array>
#include "save.h"
using namespace std;

//[문제] 파일 "int 천개"에는 몇 개인지 모르는 int값이 저장되어 있다.
// int는 값이 text로 저장되었으며 값과 값 사이에는 공백이 있다.
// 파일을 읽어 int값 1000개를 메모리에 저장하라.

//--------
int main()
//--------
{
	ifstream in{ "int 1000개" };			
	
	array<int, 1000> a;								// array 사용
	for (int i{}; i < 1'000; ++i)
		in >> a[i];
	
	// 가장 큰 값을 찾아 화면에 출력하라.
	auto p = max_element(a.begin(), a.end());		// algorithm 사용
	cout << "최댓값 - " << *p << endl;				// 여기서 p는 Iterator이므로 *p로 값을 받음
	save("소스.cpp");
}

==================================================
소스.cpp 2023-03-09 목요일 오후 3:03:06 
==================================================
// 2023. 3. 9 목										(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 int
//===========================================================================
#include <iostream>
#include <array>
#include "save.h"
using namespace std;

//int a[10];  초기화 하지 x 변수 실행 파일 크기 같음
//int b[10]{ 1 };  초기화 한 변수 실행 파일 크기 다름

//--------
int main()
//--------
{		
	array<int, 10> a;
	int x{ 123 };

	cout << "스택에 있는 x - " << addressof(x) << endl;
	cout << "스택에 있는 a[0] - " << addressof(a[0]) << endl;
	// 유사 번지가 나옴
	save("소스.cpp");
}

==================================================
소스.cpp 2023-03-09 목요일 오후 3:06:34 
==================================================
// 2023. 3. 9 목										(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 int
//===========================================================================
#include <iostream>
#include <array>
#include "save.h"
using namespace std;

array<int, 10> ga;
int gx{ 123 };

//--------
int main()
//--------
{
	array<int, 10> a;
	int x{ 123 };
		
	cout << "STACK에 있는 x - " << addressof(x) << endl;				// STACK : 함수 호출 시에 사용되는 지역 변수들과 함수 호출에 필요한 데이터들을 임시로 저장하는 메모리 영역
	cout << "STACK에 있는 a[0] - " << addressof(a[0]) << endl;
	cout << endl;

	cout << "DATA에 있는 gx - " << addressof(gx) << endl;			// DATA : 프로그램의 전역 변수(global variable)와 정적 변수(static variable)가 저장되는 메모리 영역
	cout << "DATA에 있는 ga[0] - " << addressof(ga[0]) << endl;
	cout << endl;

	cout << "CODE에 있는 main - " << addressof(main) << endl;		// CODE : 프로그램의 실행 가능한 명령어들이 저장되는 메모리 영역
	cout << "CODE에 있는 save - " << addressof(save) << endl;		// CODE는 읽기 전용 메모리로서, 프로그램의 실행 중에는 이 영역의 내용을 수정할 수 x

																	// HEAP : 프로그래밍에서 동적 메모리 할당을 위해 사용되는 메모리 영역
																	// 프로그램이 종료되면 메모리를 해제 시켜줘야 함

	save("소스.cpp");
}

==================================================
소스.cpp 2023-03-09 목요일 오후 3:16:49 
==================================================
// 2023. 3. 9 목										(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 int
//===========================================================================
#include <iostream>
#include <array>
#include "save.h"
using namespace std;

array<int, 10> ga;								// int{} 값으로 다 채운다
int gx{ 123 };

//--------
int main()
//--------
{		
	array<int, 1'000> a;						// 1000개의 4바이트 메모리공간을 연속으로 확보함
	for (int i{}; i < 1000; ++i) {				// 최대값 - 0x7F FF FF FF 
		a[i] = i + 1;
	}

	// a에 있는 int 1000개를 파일에 저장하려고 한다
	//[문제] 파일의 크기는 얼마나 될까?


	save("소스.cpp");
}

==================================================
소스.cpp 2023-03-13 월요일 오후 2:06:17 
==================================================
// 2023. 3. 13 월56									(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 int
// 파일에 int를 메모리 크기 그대로 읽고 쓰기 bianry mode FILE I/O
//===========================================================================
#include <iostream>
#include <array>
#include <fstream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{		
	array<int, 1000> a;														// contiguous 메모리 자료형 - array, string, vector -> 성능 최고
	ofstream out{ "스택에 있는 int 천개", ios::binary };						// 메모리 그대로 저장하고 싶으면 binary-mode 사용

	
	out.write( reinterpret_cast<char *>(a.data()), sizeof(int)*1'000);		// 저수준 메모리 그대로 파일에 기록한다. / << 고수준 입출력 
																			// enter키 -> CR + LF; binary mode 와 text의 차이점 알아보기 
																			// 엔터키를 변환하지 않으려면 bianry로 파일을 열어야함
	save("소스.cpp");
}

==================================================
소스.cpp 2023-03-13 월요일 오후 2:10:57 
==================================================
// 2023. 3. 13 월56									(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 int
// 파일에 int를 메모리 크기 그대로 읽고 쓰기 bianry mode FILE I/O
//===========================================================================
#include <iostream>
#include <array>
#include <fstream>
#include <numeric>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{		
	array<int, 1000> a;														
	iota(a.begin(), a.end(), 1);											// a 초기화
	
	ofstream out{ "스택에 있는 int 천개", ios::binary };						
	out.write((const char*) &a, sizeof(int) * 1'000);	

	save("소스.cpp");
}

==================================================
소스.cpp 2023-03-13 월요일 오후 2:37:52 
==================================================
// 2023. 3. 13 월56									(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 int
// 파일에 int를 메모리 크기 그대로 읽고 쓰기 bianry mode FILE I/O
//===========================================================================
#include <iostream>
#include <array>
#include <fstream>
#include <format>
#include "save.h"
using namespace std;

// [문제] 파일 "int 천개"에 int 값 1000개가 binary mode로 기록되어 있다.
// 메모리로 다 읽어 온 후 화면에 값을 출력하라
// (읽기는 read함수로 가능)

//--------
int main()
//--------
{
	ifstream in{ "int 천개", ios::binary };
	array<int, 1000> a;
	in.read((char*) &a, sizeof(int) * 1'000);

	for (int num : a) {
		cout << format( " {:8}", num);
	}
	
	save("소스.cpp");
}

==================================================
소스.cpp 2023-03-13 월요일 오후 2:51:52 
==================================================
// 2023. 3. 13 월56									(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 class
//===========================================================================
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidChar{ 'a', 'z' }; 
uniform_int_distribution<int> uidNum{ 1, 10'000 };	// int 생략가능
class Dog {
	char c;
	int n;
public:
	Dog() {
		c = uidChar(dre);
		n = uidNum(dre);
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << "글자 - " << dog.c << ", 숫자 - " << dog.n;
	}
};

// [문제] Dog 천 객체를 생성하여 파일 "Dog 천개"에 binary mode로 저장하라.
//--------
int main()
//--------
{
	ofstream dogs{ "Dog 천개", ios::binary };

	for (int i{}; i < 1000; ++i) {				// File 열기 모드 2가지				File에 읽고 쓰는 방법
		Dog dog;								// 1. default = text				1. 고수준, <<, >>
		dogs << dog << endl;					// 2. binary mode					2. 저수준, read, write
	}											// 열기랑 쓰기랑 교차 가능
	save("소스.cpp");
}

==================================================
소스.cpp 2023-03-13 월요일 오후 3:03:38 
==================================================
// 2023. 3. 13 월56									(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 class
//===========================================================================
#include <iostream>
#include <fstream>
#include <random>
#include <array>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidChar{ 'a', 'z' }; // <int> 생략가능
uniform_int_distribution<int> uidNum{ 1, 10'000 };
class Dog {							// char + int = 5바이트지만 실제로는 8바이트 저장 -> 속도가 빠름
	char c;
	int n;
public:
	Dog() {
		c = uidChar(dre);
		n = uidNum(dre);
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << "글자 - " << dog.c << ", 숫자 - " << dog.n;
	}
};

// [문제] Dog 천 객체를 생성하여 파일 "Dog 천개"에 binary mode로 저장하라.
// write 함수로 Dog 객체 메모리 그대로 저장하라
//--------
int main()
//--------
{
	ofstream out{ "Dog 천개", ios::binary };
	array<Dog, 1000> dogs;
	cout << "dogs의 크기 - " << sizeof dogs << endl;
	
	out.write((char*)&dogs, sizeof dogs);

	save("소스.cpp");
}

==================================================
소스.cpp 2023-03-13 월요일 오후 3:10:49 
==================================================
// 2023. 3. 13 월56									(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 class
//===========================================================================
#include <iostream>
#include <fstream>
#include <random>
#include <array>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidChar{ 'a', 'z' }; // <int> 생략가능
uniform_int_distribution<int> uidNum{ 1, 10'000 };
class Dog {							// char + int = 5바이트지만 실제로는 8바이트 저장 -> 속도가 빠름
	char c;
	int n;
public:

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << "글자 - " << dog.c << ", 숫자 - " << dog.n;
	}
};

// [문제] Dog 천 객체가 "Dog 천개"에 binary mode로 메모리 크기대로 저장되어있다.
// 메모리로 읽어와라.
// 읽은 정보를 화면에 출력하라.
//--------
int main()
//--------
{
	array<Dog, 1000> dogs;
	ifstream in{ "Dog 천개", ios::binary };
	if (!in) {
		exit(0);		// 파일 열기 실패
	}

	in.read((char*)&dogs, sizeof dogs);
	for (Dog dog : dogs) {
		cout << dog << endl;
	}

	save("소스.cpp");
}

==================================================
소스.cpp 2023-03-13 월요일 오후 3:19:52 
==================================================
// 2023. 3. 13 월56									(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 class
//===========================================================================
#include <iostream>
#include <fstream>
#include <array>
#include "save.h"
using namespace std;

// [문제] "int 천개"에는 int 값 1000개가 binary mode로 
// 4000바이트가 메모리에 있는 그대로 기록되어있다.
// 메모리로 읽어와라.
// 값이 100보다 작은 것은 모두 몇 개인가 출력하라.
//--------
int main()
//--------
{
	ifstream in{ "int 천개", ios::binary };
	array<int, 1000> numbers;
	in.read((char*)&numbers, sizeof numbers);

	// 다음 시간에는 알고리즘으로 해결
	int cnt{};
	for (int num : numbers) {
		if (num < 100) {
			++cnt;
		}
	}
	cout << "100보다 작은 숫자 -  " << cnt << endl;
	save("소스.cpp");
}

==================================================
소스.cpp 2023-03-16 목요일 오후 1:45:33 
==================================================
// 2023. 3. 16 목56									(3주 1일)
//---------------------------------------------------------------------------
// 더 많은(STACK의 크기를 넘는) Data 처리하기
//===========================================================================
#include <iostream>
#include <array>
#include "save.h"
using namespace std;


//--------
int main()
//--------
{
	array<char, 1'000'000> a;			
										
	int i{};
	for (char& c : a) {
		c = ++i;
	}								// 돌아가는 이유 : 컴파일러가 메모리를 사용안하는걸 알기 때문에 돌아간다.

	for (char c : a) {
		cout << c << ' ';
	}								// 메모리 사용하자마자 오버플로우 발생
	save("소스.cpp");
}

==================================================
소스.cpp 2023-03-16 목요일 오후 3:09:19 
==================================================
// 2023. 3. 16 목56									(3주 1일)
//---------------------------------------------------------------------------
// 더 많은 데이터 처리하기 - new를 사용한 메모리 동적할당
//===========================================================================
#include <iostream>
#include <memory>
#include <chrono>
#include "save.h"
using namespace std;

// [문제] 스마트 포인터의 동작을 관찰할 수 있도록 class Dog를 사용

//--------
int main()
//--------
{
	save("소스.cpp");

	while(true){
		int num{200'000'000};									// 800메가바이트
		/*unique_ptr<int[]> p{ new int[num] };*/
		int* p = new int[num];

		for (int i{}; i < num; ++i) {
			p[i] = i + 1;
		}

		long long sum{};
		for (int k{}; k < num; ++k) {
			sum += p[k];
		}
		cout << "1부터 num까지 합계 = " << sum << endl;
		this_thread::sleep_for(100ms);
	}
}

==================================================
소스.cpp 2023-03-16 목요일 오후 3:10:08 
==================================================
// 2023. 3. 16 목56									(3주 1일)
//---------------------------------------------------------------------------
// 더 많은 데이터 처리하기 - new를 사용한 메모리 동적할당
//===========================================================================
#include <iostream>
#include "save.h"
using namespace std;

// [문제] 사용자가 원하는 수 만큼 int를 저장할 메모리를 할당하라
// 메모리의 값을 1부터 값을 증가시키며 채워라
// 합계를 화면에 출력하라
// 이 과정을 영원히 반복하라

//--------
int main()
//--------
{

	save("소스.cpp");

	while(true){
		cout << "몇 개의 int를 만들까요? ";						// Memory Manager(MM)한테 new int[num] 요청
		int num{2000'000'000};									// MM가 메모리 사용 가능 번지를 return
		cin >> num;												// 그 자리에 메모리 할당, 다 사용 후 메모리 해제

		if (num <= 0) {
			cout << "0보다 큰 수를 입력하세요" << endl;
			continue;
		}
		int* p = new int[num];									// 시스템에 자원 요청
		
		for (int i{}; i < num; ++i) {
			p[i] = i + 1;
		}
		long long sum{};
		for (int k{}; k < num; ++k) {
			sum += p[k];
		}

		cout << "1부터 num까지 합계 = " << sum << endl;
		delete[] p;												// 자원 반환
	}
}

==================================================
소스.cpp 2023-03-16 목요일 오후 3:13:36 
==================================================
// 2023. 3. 16 목56									(3주 1일)
//---------------------------------------------------------------------------
// 더 많은 데이터 처리하기 - new를 사용한 메모리 동적할당
//===========================================================================
#include <iostream>
#include "save.h"
using namespace std;

// [문제] 스마트포인터의 동작을 관찰할 수 있도록 class Dog 사용
class Dog {
	char c[100'000'000];
public:
	Dog() {
		cout << "Dog 생성" << endl;
	}
	~Dog() {
		cout << "Dog 소멸" << endl;
	}
};
//--------
int main()
//--------
{

	save("소스.cpp");
	int cnt{};
	while(true){
		cout << ++cnt << endl;
		Dog* dog = new Dog[10];					// sizeof(Dog) * 10 = 10바이트
	}
}

==================================================
소스.cpp 2023-03-16 목요일 오후 3:15:59 
==================================================
// 2023. 3. 16 목56									(3주 1일)
//---------------------------------------------------------------------------
// 더 많은 데이터 처리하기 - new를 사용한 메모리 동적할당
//===========================================================================
#include <iostream>
#include <chrono>
#include "save.h"
using namespace std;

// [문제] 스마트포인터의 동작을 관찰할 수 있도록 class Dog 사용
class Dog {
	char c[100'000'000];
public:
	Dog() {
		cout << "Dog 생성" << endl;
	}
	~Dog() {
		cout << "Dog 소멸" << endl;
	}
};
//--------
int main()
//--------
{
	save("소스.cpp");
	int cnt{};
	while(true){
		cout << ++cnt << endl;
		unique_ptr<Dog[]> dog{ new Dog[10] };					// RAII 
		this_thread::sleep_for(1s);
	}
}

==================================================
소스.cpp2023-03-20 월요일 오후 1:40:48
==================================================
// 2023. 3. 20 월56									(3주 2일)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 더 많은 자료 처리하기 - new를 사용한 메모리 동적할당
//===========================================================================
#include <iostream>
#include <chrono>
#include "save.h"
using namespace std;

// [문제] 스마트포인터의 동작을 관찰할 수 있도록 class Dog 사용
class Dog {
public:
	Dog() {cout << "Dog 생성" << endl;}
	~Dog() {cout << "Dog 소멸" << endl;}
};
void f() {
	Dog* p = new Dog;		// 생성만 되고 소멸은 x

	// 여기서 문제가 생겼다
	throw 1;
	
	delete p;				// 소멸
}
//--------
int main()
//--------
{
	save("소스.cpp");
	f();

}

==================================================
소스.cpp2023-03-20 월요일 오후 1:42:18
==================================================
// 2023. 3. 20 월56									(3주 2일)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 더 많은 자료 처리하기 - new를 사용한 메모리 동적할당
//===========================================================================
#include <iostream>
#include <chrono>
#include "save.h"
using namespace std;

// [문제] 스마트포인터의 동작을 관찰할 수 있도록 class Dog 사용
class Dog {
public:
	Dog() {cout << "Dog 생성" << endl;}
	~Dog() {cout << "Dog 소멸" << endl;}
};
void f() {
	Dog* p = new Dog;		// 생성만 되고 소멸은 x

	throw 1;				// 여기서 문제가 생겼다
	
	delete p;				// 소멸
}
//--------
int main()
//--------
{
	save("소스.cpp");

	try {					// 문제 해결하기 위한 try catch  사용
		f();
	}
	catch (int n) {
		cout << "예외를 처리함" << endl;
	}

}

==================================================
소스.cpp2023-03-20 월요일 오후 1:44:21
==================================================
// 2023. 3. 20 월56									(3주 2일)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 더 많은 자료 처리하기 - new를 사용한 메모리 동적할당
//===========================================================================
#include <iostream>
#include <chrono>
#include "save.h"
using namespace std;

// [문제] 스마트포인터의 동작을 관찰할 수 있도록 class Dog 사용
class Dog {
public:
	Dog() {cout << "Dog 생성" << endl;}
	~Dog() {cout << "Dog 소멸" << endl;}
};
void f() {							
	
	unique_ptr<Dog> p{ new Dog };		// RAII, 지역 객체 생성

	// 예외가 발생하면 stack unwinding을 하기 때문에
	// p가 소유한 Dog의 소멸자를 반드시 호출한다.
	throw 1;							// 여기서 문제가 생겼다

	cout << "이 문장이 출력되면 노트북 버려라" << endl;
}										
//--------
int main()
//--------
{
	save("소스.cpp");

	try {					
		f();
	}
	catch (int n) {
		cout << "예외를 처리함" << endl;
	}

}

==================================================
소스.cpp2023-03-20 월요일 오후 2:07:56
==================================================
// 2023. 3. 20 월56									(3주 2일)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 실습 - 파일 자료 처리하기
//===========================================================================
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] "소스.cpp" 파일을 읽어 소문자를 대문자로 변환하여
// "소스대문자.cpp" 파일에 저장하라

//--------
int main()
//--------
{	
	// 시험문제 나올수도 있음

	ifstream in{ "소스.cpp" };				// 소스.cpp를 읽기 모드로 연다
	ofstream out{ "소스대문자.cpp" };		// 소스대문자.cpp를 쓰기 모드로 연다
	
	char c;
	in >> noskipws;							// 띄어스기 포함하는 함수
	while (in >> c) {
		c = toupper(c);						// 대문자로 바꾸는 함수 toupper(), 소문자를 묻는 함수 islower()
		out << c;
		
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-20 월요일 오후 2:17:04
==================================================
// 2023. 3. 20 월56									(3주2일)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 실습 - 파일 자료 처리하기
//===========================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] "소스.cpp" 파일을 읽어 소문자를 대문자로 변환하여
// "소스대문자.cpp" 파일에 저장하라

//--------
int main()
//--------
{
	// 시험문제 나올수도 있음

	ifstream in{ "소스.cpp" };				// 소스.cpp를 읽기 모드로 연다
	ofstream out{ "소스대문자.cpp" };		// 소스대문자.cpp를 쓰기 모드로 연다

	transform(istreambuf_iterator<char>{in}, {},		// 알고리즘 함수 사용
		ostreambuf_iterator<char>{out}, [](char c) {
			return c = toupper(c);
		});
	
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-20 월요일 오후 2:19:58
==================================================
// 2023. 3. 20 월56									(3주 2일)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 실습 - 파일 자료 처리하기
//===========================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] "소스.cpp" 파일을 읽어 소문자를 대문자로 변환하여
// "소스대문자.cpp" 파일에 저장하라

//--------
int main()
//--------
{
	// 시험문제 나올수도 있음

	ifstream in{ "소스.cpp" };				// 소스.cpp를 읽기 모드로 연다
	ofstream out{ "소스대문자.cpp" };		// 소스대문자.cpp를 쓰기 모드로 연다

	transform(istreambuf_iterator<char>{in}, {},			
		ostreambuf_iterator<char>{out}, [](char c) {
			// 숫자는 *로
			if (isdigit(c)) {				// 숫자인지 확인하는 함수 isdigit()
				c = '*';
			}
			return c;
		});
	
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-20 월요일 오후 3:09:28
==================================================
// 2023. 3. 20 월56									(3주 2일)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type
//===========================================================================
#include <iostream>
#include <array>
#include <random>
#include <format>
#include <ranges>		// C++ 20
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 100만개를 만들고 random 값으로 채워라
// 오름차순으로 정렬하라
// 값을 출력하라


array<int, 1'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 1'000'000 };

int 어떻게(const void* a, const void* b) {							// qsort가 void* 타입의 포인터를 사용하여 배열의 요소를 비교함
	return *(int*)a - *(int*)b;
}
//--------
int main()
//--------
{
	for (int& number : numbers) {
		number = uid(dre);
	}

	// 오름차순 정렬
	qsort(numbers.data(), numbers.size(), sizeof(int), 어떻게);		// C함수이지만 generic -> 자료형에 관계없이 사용가능 
																	// 인자 : qsort(배열 시작, 크기, 자료형, 정렬방식);
	// 뒤에서 100개만 출력

	for (int number : numbers |										// syntatic sugar -> for(auto i = numbers.begin(); i != numbers.end(); ++i)
		views::drop(numbers.size()- 100)) 
	{									
		cout << format("{:8}", number);
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-20 월요일 오후 3:12:47
==================================================
// 2023. 3. 20 월56									(3주 2일)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type
//===========================================================================
#include <iostream>
#include <array>
#include <random>
#include <format>
#include <ranges>		// C++ 20
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 100만개를 만들고 random 값으로 채워라
// 오름차순으로 정렬하라
// 값을 출력하라


array<int, 1'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 1'000'000 };

int 어떻게(const void* a, const void* b) {
	return *(int*)a - *(int*)b;
}
//--------
int main()
//--------
{
	for (int& number : numbers) {
		number = uid(dre);
	}

	// 오름차순 정렬
	sort(numbers.begin(), numbers.end());						// O(nlogn)

	// range::sort(numbers);
	// 뒤에서 100개만 출력

	for (int number : numbers |									// syntatic sugar -> for(auto i = numbers.begin(); i != numbers.end(); ++i)
		views::drop(numbers.size()- 100)) 
	{								
		cout << format("{:8}", number);
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-20 월요일 오후 3:16:57
==================================================
// 2023. 3. 20 월56									(3주 2일)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type
//===========================================================================
#include <iostream>
#include <array>
#include <random>
#include <format>
#include <ranges>		// C++ 20
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 100만개를 만들고 random 값으로 채워라
// 오름차순으로 정렬하라
// 값을 출력하라


array<int, 1'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 1'000'000 };

//bool 어떻게(int a, int b) {
//	return a > b;
//}

class Dog {
public:
	bool operator()(int a, int b) {
		return a > b;
	}
};
//--------
int main()
//--------
{
	for (int& number : numbers) {
		number = uid(dre);
	}

	// 내림차순 정렬
	// 정렬방법은 sort에게 알려줘야 함(함수를 인자로 전달)
	sort(numbers.begin(), numbers.end(), Dog());				// O(nlogn) / Dog() 대신에 어떻게 사용가능 / callable type : 호출가능한 타입

	// range::sort(numbers);
	// 뒤에서 100개만 출력

	for (int number : numbers |									// syntatic sugar -> for(auto i = numbers.begin(); i != numbers.end(); ++i)
		views::drop(numbers.size()- 100)) 
	{								
		cout << format("{:8}", number);
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-23 목요일 오후 1:41:29
==================================================
// 2023. 3. 23 목56									(4주 1일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type
//===========================================================================
#include <iostream>
#include <array>
#include <random>
#include <format>
#include <ranges>		// C++ 20
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 100만개를 만들고 random 값으로 채워라
// 오름차순으로 정렬하라
// 값을 출력하라

array<int, 1'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 1'000'000 };

//bool 어떻게(int a, int b) {
//	return a > b;
//}

class Dog {
public:
	bool operator()(int a, int b) {			// int 대신에 const int&를 쓸 수 있지만 &가 8바이트를 잡아먹기 때문에 비효율적
		return a > b;
	}
};
//--------
int main()
//--------
{
	for (int& number : numbers) {
		number = uid(dre);
	}

	// 내림차순 정렬
	sort(numbers.begin(), numbers.end(), Dog());				// O(nlogn) / corable type : 호출가능한 타입
	// sort에서 begin은 시작위치[0], end는 [999'999]다음 위치, Dog()는 1바이트
	// ranges::sort(numbers);
	// 뒤에서 100개만 출력

	for (int number : numbers |									// syntatic sugar -> for(auto i = numbers.begin(); i != numbers.end(); ++i)
		views::drop(numbers.size()- 100)) 
	{								
		cout << format("{:8}", number);
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-23 목요일 오후 1:44:26
==================================================
// 2023. 3. 23 목56									(4주 1일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type
//===========================================================================
#include <iostream>
#include <array>
#include <random>
#include <format>
#include <ranges>		// C++ 20
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 100만개를 만들고 random 값으로 채워라
// 오름차순으로 정렬하라
// 값을 출력하라

array<int, 1'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 1'000'000 };

//bool 어떻게(int a, int b) {
//	return a > b;
//}

class Dog {
public:
	bool operator()(int a, int b) {			// int 대신에 const int&를 쓸 수 있지만 &가 8바이트를 잡아먹기 때문에 비효율적
		return a < b;
	}
};
//--------
int main()
//--------
{
	Dog dog;
	cout << boolalpha << dog.operator()(3, 4) << endl;		// True
	cout << boolalpha << dog(200, 100) << endl;				// False
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-23 목요일 오후 1:52:02
==================================================
// 2023. 3. 23 목56									(4주 1일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type
//===========================================================================
#include <iostream>
#include <array>
#include <random>
#include <format>
#include <ranges>		// C++ 20
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 100만개를 만들고 random 값으로 채워라
// 오름차순으로 정렬하라
// 값을 출력하라

array<int, 1'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 1'000'000 };

//--------
int main()
//--------
{
	for (int& number : numbers) {
		number = uid(dre);
	}

	// 정렬방법은 sort에게 알려줘야 함(함수를 인자로 전달)
			
	sort(numbers.begin(), numbers.end(), [](int a, int b) {
		return a > b;
		});				// 람다 사용 -> sort가 필요한건 기능이라 람다로 대체한다.

	// 뒤에서 100개만 출력

	for (int number : numbers |								
		views::drop(numbers.size() - 100))
	{
		cout << format("{:8}", number);
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-23 목요일 오후 1:55:18
==================================================
// 2023. 3. 23 목56									(4주 1일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type, 호출가능 타입
//===========================================================================
#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	
	cout << typeid([]() {
		cout << "안녕하세요? 난 람다입니다." << endl;
	}).name() << endl;

	save("소스.cpp");
}

==================================================
소스.cpp2023-03-23 목요일 오후 1:56:12
==================================================
// 2023. 3. 23 목56									(4주 1일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type, 호출가능 타입
//===========================================================================
#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	auto lambda = []() {
		cout << "안녕하세요? 난 람다입니다." << endl;
	};
	lambda();
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-23 목요일 오후 2:02:10
==================================================
// 2023. 3. 23 목56									(4주 1일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type, 호출가능 타입
//===========================================================================
#include <iostream>
#include "save.h"
using namespace std;

class Dog {};
class lambda {		// 람다는 함수의 객체이다. 비주얼 스튜디오에서는 클래스로 람다를 만듬
public:
	void operator()() {
		cout << "안녕하세요? 난 람다입니다." << endl;
	};
};
//--------
int main()
//--------
{
	
	Dog dog;

	cout << typeid(dog).name() << endl;
	
	lambda();
	cout << typeid(lambda).name() << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-23 목요일 오후 2:07:42
==================================================
// 2023. 3. 23 목56									(4주 1일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type, 호출가능 타입
//===========================================================================
#include <iostream>
#include <array>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{

	array<string, 5> a{
		"전광훈"s, "교회"s, "이번엔"s, "장위8구역"s, "사우나건물"s
	};
	sort(a.begin(), a.end(), [](const string& a, const string& b) {			// 람다는 CODE에 저장
		return a < b;
		});
	for (const string& str : a) {
		cout << str << endl;
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-23 목요일 오후 2:31:32
==================================================
// 2023. 3. 23 목56									(4주 1일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type, 호출가능 타입
//===========================================================================
#include <iostream>
#include <array>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	
	// 호출가능한 타입
	// 1. 함수 포인터 -> cout << typeid(main).name() << endl; == CODE segement에서 main함수의 시작번지를 포인터로 가리킴
	// 2. 함수 객체(함수호출연산자를 오버로딩한 클래스 자체)
	// 3. 람다(기능만이 필요한 경우에 사용)
	// 4. 멤버 함수 포인터
	// 5. function 
	
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-23 목요일 오후 2:39:09
==================================================
// 2023. 3. 23 목56									(4주 1일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type, 호출가능 타입
//===========================================================================
#include <iostream>
#include <array>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;


void jump() {
	cout << "점프" << endl;
}

void slide() {
	cout << "슬라이드" << endl;
}
//--------
int main()
//--------
{
	// int(*f)( void ) = main;
	// (*f)();
	
	// 게임에서 키의 동작을 실행중에 바꾸고 싶다.
	save("소스.cpp");

	while (true) {
		cout << "a, l, o, q 중에 하나를 누르세요 ";
		char c;
		cin >> c;
		switch (c) {
		case 'a':
			jump();
			break;
		case 'l':
			slide();
			break;
		case 'o':
			break;
		case 'q':
			return 0;
		}
	}				// 닙땜 코딩 : 바꿀수 없음
}

==================================================
소스.cpp2023-03-23 목요일 오후 2:44:26
==================================================
// 2023. 3. 23 목56									(4주 1일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type, 호출가능 타입
//===========================================================================
#include <iostream>
#include <array>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;


void jump() {
	cout << "점프" << endl;
}

void slide() {
	cout << "슬라이드" << endl;
}
//--------
int main()
//--------
{
	// int(*f)( void ) = main;
	// (*f)();
	
	// 게임에서 키의 동작을 실행중에 바꾸고 싶다.
	save("소스.cpp");

	void(*akey)(void) = jump;
	void(*lkey)(void) = slide;

	while (true) {
		cout << "a, l, o, q 중에 하나를 누르세요 ";
		char c;
		cin >> c;
		switch (c) {
		case 'a':
			akey();
			break;
		case 'l':
			lkey();
			break;
		case 'o':
			// 여기서 기능 변경
			if (akey == jump) {
				akey = slide;
				lkey = jump;
			}
			else {
				akey = jump;
				lkey = slide;
			}
			break;
		case 'q':
			return 0;
		}
	}
}

==================================================
소스.cpp2023-03-23 목요일 오후 3:09:39
==================================================
// 2023. 3. 23 목56									(4주 1일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type, 호출가능 타입
//===========================================================================
#include <iostream>
#include <random>
#include <format>
#include <array>
#include <algorithm>
#include <ranges>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution uidNum{ 1, 100'0000 };
uniform_int_distribution uidLen{ 1, 50 };
uniform_int_distribution<int> uidName{ 'a', 'z' };

class Dog {
	int num;
	string name;

public:
	Dog() {
		num = uidNum(dre);
		int len = uidLen(dre);
		for (int i = 0; i < len; ++i) {
			name += uidName(dre);
		}
	}
	int getNum() const {
		return num;
	}
	
	void show() const {
		cout << format("{:7}, {}", num, name) << endl;
	}
};

array<Dog, 100'0000> dogs;

//--------
int main()
//--------
{
	// [문제] dogs를 Dog의 num기준 오름차순으로 정렬하라.
	// 뒤에서 100객체를 show()로 출력하라
	
	sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getNum() < b.getNum();
		});
	for (const Dog& dog : dogs |
		views::drop(dogs.size() - 100)) {
		dog.show();
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-23 목요일 오후 3:11:17
==================================================
// 2023. 3. 23 목56									(4주 1일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type, 호출가능 타입
//===========================================================================
#include <iostream>
#include <random>
#include <format>
#include <array>
#include <algorithm>
#include <ranges>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution uidNum{ 1, 100'0000 };
uniform_int_distribution uidLen{ 1, 50 };
uniform_int_distribution<int> uidName{ 'a', 'z' };

class Dog {
	int num;
	string name;

public:
	Dog() {
		num = uidNum(dre);
		int len = uidLen(dre);
		for (int i = 0; i < len; ++i) {
			name += uidName(dre);
		}
	}
	int getNum() const {
		return num;
	}
	string getName() const {
		return name;
	}
	void show() const {
		cout << format("{:7}, {}", num, name) << endl;
	}
};

array<Dog, 100'0000> dogs;

//--------
int main()
//--------
{
	// [문제] dogs를 Dog의 namer 길이 기준 오름차순으로 정렬하라.
	// 뒤에서 100객체를 show()로 출력하라
	
	sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getName().size() < b.getName().size();
		});
	for (const Dog& dog : dogs |
		views::drop(dogs.size() - 100)) {
		dog.show();
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-23 목요일 오후 3:17:45
==================================================
// 2023. 3. 23 목56									(4주 1일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 정렬(sort) - callable type, 호출가능 타입
//===========================================================================
#include <iostream>
#include <functional>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	save("소스.cpp");

	// Callable types
	// 1. function pointer
	// 2. function object 
	// 3. lambda
	// -> function 으로 통합

	int(*fp)() = main;
	function<int()> f = main;		// function<리턴값(인자)> 면 함수를 받을 수 있음
	f = fp;
	
}

==================================================
소스.cpp2023-03-27 월요일 오후 1:38:42
==================================================
// 2023. 3. 27 월56									(4주 2일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 관찰 클래스 작성 - 1. C++ 복습 2. 앞으로 발전시켜서 STL컨테이너로 만듦
//===========================================================================
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] 자원을 할당하는 클래스 String (표준 sting과 유사한)를 작성하자.
// special 함수의 동작을 관찰하자

//--------
int main()
//--------
{
	string s;
	cout << sizeof s << endl;		// size_t(4), +8, 16 -> 32
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-27 월요일 오후 2:01:36
==================================================
// 2023. 3. 27 월56									(4주 2일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 관찰 클래스 작성 - 1. C++ 복습 2. 앞으로 발전시켜서 STL컨테이너로 만듦
//===========================================================================
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] 자원을 할당하는 클래스 String (표준 sting과 유사한)를 작성하자.
// special 함수의 동작을 관찰하자

class String {
	size_t len{};
	char* p{};
public:
	String(const char * str) : len{strlen( str )} {
		p = new char[len];
		memcpy(p, str, len);		// DMA, 메모리 복사 -> cpu 개입 x
	}

	size_t size() const{
		return len;
	}

	friend ostream& operator<<(ostream& os, const String& s) {
		for (int i = 0; i < s.len; ++i) {
			os << s.p[i];
		}
		return os;
	}
	~String() {}
};

//--------
int main()
//--------
{	
	String s{"1234567890"};
	cout << s.size() << ' - ' << s << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-27 월요일 오후 2:37:29
==================================================
// 2023. 3. 27 월56									(4주 2일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 관찰 클래스 작성 - 1. C++ 복습 2. 앞으로 발전시켜서 STL컨테이너로 만듦
//===========================================================================
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
using namespace std;

// [문제] 자원을 할당하는 클래스 String (표준 sting과 유사한)를 작성하자.
// special 함수의 동작을 관찰하자
// 모든 객체는 생성시 번호를 받는다.

bool 관찰{ false };

class String {

	size_t len{};
	char* p{};
	size_t id = ++sid;

	static size_t sid;		// 맴버변수 x

public:
	String(const char * str) : len{strlen( str )} {
		p = new char[len];
		memcpy(p, str, len);		// DMA, 메모리 복사 -> cpu 개입 x
		print("생성");
	}

	~String() {
		print("소멸");
		delete[] p;
	}
	
	void print(string s) const {
		if (관찰) {
			cout << "[" << id << "] - " << s << ", 개수: "
				<< len << ", 번지: " << (void*)p << endl;
		}
	}

	size_t size() const{
		return len;
	}

	friend ostream& operator<<(ostream& os, const String& s) {
		for (int i = 0; i < s.len; ++i) {
			os << s.p[i];
		}
		return os;
	}
};

size_t String::sid{0};

//--------
int main()
//--------
{	
	String s{"1234567890"};
	cout << s.size() << " - " << s << endl;
	
	관찰 = true;
	 save("소스.cpp");
}

==================================================
소스.cpp2023-03-27 월요일 오후 2:55:23
==================================================
// 2023. 3. 27 월56									(4주 2일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 관찰 클래스 작성 - 1. C++ 복습 2. 앞으로 발전시켜서 STL컨테이너로 만듦
//===========================================================================
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
using namespace std;

// [문제] 자원을 할당하는 클래스 String (표준 sting과 유사한)를 작성하자.
// special 함수의 동작을 관찰하자
// 모든 객체는 생성시 번호를 받는다.

bool 관찰{ false };

class String {

	size_t len{};
	char* p{};
	size_t id = ++sid;

	static size_t sid;		// 맴버변수 x

public:
	String() {
		print("디폴트 생성");
	}

	String(const char * str) : len{strlen( str )} {
		p = new char[len];
		memcpy(p, str, len);		// DMA, 메모리 복사 -> cpu 개입 x
		print("생성(char*)");
	}

	~String() {
		print("소멸");
		delete[] p;
	}
	
	void print(string s) const {
		if (관찰) {
			cout << "[" << id << "] - " << s << ", 개수: "
				<< len << ", 번지: " << (void*)p << endl;
		}
	}

	size_t size() const{
		return len;
	}

	String operator+(const String& rhs) const {
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];
		memcpy(temp.p, p, len);						// 왼쪽 String 문자열 메모리 복사
		memcpy(temp.p + len, rhs.p, rhs.len);		// 오른쪽 String 문자열을 왼쪽 String 문자열 바로 뒤에 메모리 복사
		return temp;
	}

	friend ostream& operator<<(ostream& os, const String& s) {
		for (int i = 0; i < s.len; ++i) {
			os << s.p[i];
		}
		return os;
	}

};

size_t String::sid{0};

//--------
int main()
//--------
{	
	
	관찰 = true;
	String a = "123";
	String b = "4567890";
	String c = a + b;

	cout << c << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-27 월요일 오후 3:05:53
==================================================
// 2023. 3. 27 월56									(4주 2일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 관찰 클래스 작성 - 1. C++ 복습 2. 앞으로 발전시켜서 STL컨테이너로 만듦
//===========================================================================
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
using namespace std;

// [문제] 자원을 할당하는 클래스 String (표준 sting과 유사한)를 작성하자.
// special 함수의 동작을 관찰하자
// 모든 객체는 생성시 번호를 받는다.

bool 관찰{ false };

class String {

	size_t len{};
	char* p{};
	size_t id = ++sid;

	static size_t sid;		// 맴버변수 x

public:
	String() {
		print("디폴트 생성");
	}

	String(const char * str) : len{strlen( str )} {
		p = new char[len];
		memcpy(p, str, len);		// DMA, 메모리 복사 -> cpu 개입 x
		print("생성(char*)");
	}

	String(const String& other) {
		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사생성");
	}

	String& operator=(const String& other) {
		if (this == &other) {
			return *this;
		}
		delete[] p;
		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");
	}
	~String() {
		print("소멸");
		delete[] p;
	}
	
	void print(string s) const {
		if (관찰) {
			cout << "[" << id << "] - " << s << ", 개수: "
				<< len << ", 번지: " << (void*)p << endl;
		}
	}

	size_t size() const{
		return len;
	}

	String operator+(const String& rhs) const {
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];
		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	friend ostream& operator<<(ostream& os, const String& s) {
		for (int i = 0; i < s.len; ++i) {
			os << s.p[i];
		}
		return os;
	}

};

size_t String::sid{0};

//--------
int main()
//--------
{	
	
	관찰 = true;
	String a = "123";
	String b = "4567890";
	String c;
	c = a + b;

	cout << c << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-03-27 월요일 오후 3:20:08
==================================================
// 2023. 3. 27 월56									(4주 2일)
// 3. 30 목 (5주 1일) - 학과 MT(e-class에 업로드, 출석은 대체)
// 4. 3 예비군 - 수업 함 -> 강의녹화
//---------------------------------------------------------------------------
// 관찰 클래스 작성 - 1. C++ 복습 2. 앞으로 발전시켜서 STL컨테이너로 만듦
//===========================================================================
#include <iostream>
#include <string>
#include <memory>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 자원을 할당하는 클래스 String (표준 sting과 유사한)를 작성하자.
// special 함수의 동작을 관찰하자
// 모든 객체는 생성시 번호를 받는다.

bool 관찰{ false };

class String {

	size_t len{};
	char* p{};
	size_t id = ++sid;

	static size_t sid;		// 맴버변수 x

public:

	String() {
		print("디폴트 생성");
	}

	String(const char * str) : len{strlen( str )} {
		p = new char[len];
		memcpy(p, str, len);		// DMA, 메모리 복사 -> cpu 개입 x
		print("생성(char*)");
	}

	String(const String& other) {
		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사생성");
	}

	String& operator=(const String& other) {
		if (this == &other) {
			return *this;
		}
		delete[] p;
		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");
	}
	~String() {
		print("소멸");
		delete[] p;
	}
	
	void print(string s) const {
		if (관찰) {
			cout << "[" << id << "] - " << s << ", 개수: "
				<< len << ", 번지: " << (void*)p << endl;
		}
	}

	size_t size() const{
		return len;
	}

	String operator+(const String& rhs) const {
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];
		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	friend ostream& operator<<(ostream& os, const String& s) {
		for (int i = 0; i < s.len; ++i) {
			os << s.p[i];
		}
		return os;
	}

	string getString() const {
		return string(p, len);
	}

};

size_t String::sid{0};

//--------
int main()
//--------
{	
	
	array<String, 3> news{ "사진", "촬영은", "무조건"};

	// 오름차순으로 정렬하라
	관찰 = true;

	sort(news.begin(), news.end(), [](const String& a, const String& b) {
		return  a.getString() < b.getString();
		});
	// &를 쓰는 이유는 원본을 인자로 넘겨주기 위해서
	// &가 없으면 인자를 넘길때 마다 복사생성, 소멸을 하기 때문에 메모리를 잡아먹음
	// -> 정렬만 하면 되기 때문에 임시 객체를 만들 필요가 없음
	// const 는 옵션 써도 되고 안써도 됨

	관찰 = false;

	for (const String& s : news) {
		cout << s << endl;
	}
	save("소스.cpp");
}
**************************************************************************************************************************************************************************
**************************************************************************************************************************************************************************
**************************************************************************************************************************************************************************
**************************************************************************************************************************************************************************
**************************************************************************************************************************************************************************
**************************************************************************************************************************************************************************
==================================================
소스.cpp2023-04-04 화요일 오후 6:45:17
==================================================
// 2023. 3. 30 월										(5주 1일)
//---------------------------------------------------------------------------
// 관찰 클래스 작성 - String(자원을 확보하는 클래스)
// 1. C++ 복습
// 2. 앞으로 발전시켜서 STL 컨테이너로 만듦
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <string>
#include <memory>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 자원을 할당하는 클래스 String (표준 sting과 유사한)를 작성하자.
// special 함수의 동작을 관찰하자
// 모든 객체는 생성시 번호를 받는다.

bool 관찰{ false };

// 2023.3.27 String 코딩 시작
class String {

	size_t len{};						// 확보한 자원 수
	char* p{};							// 확보한 자원의 주소
	size_t id = ++sid;					// 객체 id

	static size_t sid;					// 맴버변수 x, class의 static 변수?

public:
	// 생성자와 소멸자
	String() {
		print("디폴트 생성자");
	}

	String(const char* str) : len{ strlen(str) } {
		p = new char[len];
		memcpy(p, str, len);		// DMA, 메모리 복사 -> cpu 개입 x
		print("생성자(char*)");
	}

	~String() {
		print("소멸자");
		delete[] p;
	}

	// 복사생성자/복사할당연산자
	String(const String& other) {
		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사생성자");
	}

	String& operator=(const String& other) {
		if (this == &other) {
			return *this;
		}
		delete[] p;
		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");
		return *this;
	}

	// 이동생성자/이동할당연산자 - 2023.3.30 추가
	String(String&& other) {
		len = other.len;
		p = other.p;

		// 이동되는 객체를 정리해준다
		other.len = 0;
		other.p = nullptr;

		print("이동생성자");
	}

	String& operator=(String&& other) {
		// 자신을 이동할당하면 안된다
		if (this == &other) {
			return *this;
		}

		// 이미 확보한 자원을 해제한다
		delete[] p;

		// other를 이동한다
		len = other.len;
		p = other.p;

		// other를 초기화한다
		other.len = 0;
		other.p = nullptr;

		print("이동할당연산자");
		return *this;
	} 

	// 연산자 오버로딩 함수
	String operator+(const String& rhs) const {
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];
		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	friend ostream& operator<<(ostream& os, const String& s) {
		for (int i = 0; i < s.len; ++i) {
			os << s.p[i];
		}
		return os;
	}

	// 그 외 멤버함수들
	void print(string s) const {
		if (관찰) {
			cout << "[" << id << "] - " << s << ", 개수: "
				<< len << ", 번지: " << (void*)p << endl;
		}
	}

	size_t size() const {
		return len;
	}


	string getString() const {
		return string(p, len);
	}

};

size_t String::sid{ 0 };				// 이 변수는 클래스 밖에서 초기화한다

//--------
int main()
//--------
{
	array<String, 3> news{ "3456", "12", "789"};

	// 오름차순으로 정렬하라
	관찰 = true;

	sort(news.begin(), news.end(), [](const String& a, const String& b) {
		return  a.getString() < b.getString();
		});
	
	관찰 = false;

	for (const String& s : news) {
		cout << s << endl;
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-04-04 화요일 오후 7:19:39
==================================================
// 2023. 3. 30 월										(5주 1일)
//---------------------------------------------------------------------------
// 관찰 클래스 작성 - String(자원을 확보하는 클래스)
// 1. C++ 복습
// 2. 앞으로 발전시켜서 STL 컨테이너로 만듦
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	관찰 = true;

	array<String, 3> news{ "3456", "12", "789"};

	sort(news.begin(), news.end(), [](const String& a, const String& b) {
		return  a.getString() < b.getString();
		});

	for (const String& s : news) {
		cout << s << endl;
	}
	save("소스.cpp");
	save("String.h");
	save("String.cpp");
}

==================================================
String.h2023-04-04 화요일 오후 7:19:39
==================================================
//--------------------------------------------------------------------------------------------------
// String.h - 표준 string과 유사한 클래스
// 
// 2023. 3. 30
//--------------------------------------------------------------------------------------------------
#pragma once

class string;
class ostream;

// 2023.3.27 String 코딩 시작
class String {

	size_t len{};						// 확보한 자원 수
	char* p{};							// 확보한 자원의 주소
	size_t id = ++sid;					// 객체 id

	static size_t sid;					// 맴버변수 x, class의 static 변수?

public:
	// 생성자와 소멸자
	String();
	String(const char* str);
	~String();

	// 복사생성자/복사할당연산자
	String(const String& other);

	String& operator=(const String& other);

	// 이동생성자/이동할당연산자 - 2023.3.30 추가
	String(String&& other);

	String& operator=(String&& other);

	// 연산자 오버로딩 함수
	String operator+(const String& rhs) const;

	friend std::ostream& operator<<(std::ostream& os, const String& s) {
			for (int i = 0; i < s.len; ++i) {
				os << s.p[i];
			}
			return os;
	}

	// 그 외 멤버함수들
	void print(std::string) const;
	size_t size() const;
	std::string getString() const;
};

==================================================
String.cpp2023-04-04 화요일 오후 7:19:39
==================================================
//--------------------------------------------------------------------------------------------------
// String.h - 표준 string과 유사한 클래스
// 
// 2023. 3. 30
//--------------------------------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "String.h"

bool 관찰{ false };						// 스페셜 함수의 동작을 관찰하려면 true로 바꿀 것


// 생성자와 소멸자
String::String() {
	print("디폴트 생성자");
}

String::String(const char* str) 
	: len{ strlen(str) } {
	p = new char[len];
	memcpy(p, str, len);		
	print("생성자(char*)");
}

String::~String() {
	print("소멸자");
	delete[] p;
}

	// 복사생성자/복사할당연산자
String::String(const String& other) {
	len = other.len;
	p = new char[len];
	memcpy(p, other.p, len);

	print("복사생성자");
}

String& String::operator=(const String& other) {
	if (this == &other) {
		return *this;
	}
	delete[] p;

	len = other.len;
	p = new char[len];
	memcpy(p, other.p, len);

	print("복사할당연산자");
	return *this;
}

// 이동생성자/이동할당연산자 - 2023.3.30 추가
String::String(String&& other) {
	len = other.len;
	p = other.p;

	// 이동되는 객체를 정리해준다
	other.len = 0;
	other.p = nullptr;

	print("이동생성자");
}

String& String::operator=(String&& other) {
	// 자신을 이동할당하면 안된다
	if (this == &other) {
		return *this;
	}

	// 이미 확보한 자원을 해제한다
	delete[] p;

	// other를 이동한다
	len = other.len;
	p = other.p;

	// other를 초기화한다
	other.len = 0;
	other.p = nullptr;

	print("이동할당연산자");
	return *this;
}

	// 연산자 오버로딩 함수
String String::operator+(const String& rhs) const {
	String temp;
	temp.len = len + rhs.len;
	temp.p = new char[temp.len];
	memcpy(temp.p, p, len);
	memcpy(temp.p + len, rhs.p, rhs.len);
	return temp;
}

// 그 외 멤버함수들
void String::print(std::string s) const {
	if (관찰) {
		std::cout << "[" << id << "] - " << s << ", 개수: "
			<< len << ", 번지: " << (void*)p << std::endl;
	}
}

size_t String::size() const {
	return len;
}


std::string String::getString() const {
	return std::string(p, len);
}

size_t String::sid{ 0 };				// 이 변수는 클래스 밖에서 초기화한다


==================================================
소스.cpp2023-04-04 화요일 오후 7:47:59
==================================================
// 2023. 3. 30 월										(5주 1일)
//---------------------------------------------------------------------------
// STL 시작
// 
// STL - 자료구조 + 알고리즘
// Generic Programming : 자료형과 무관한
// Container : 자료구조
// Algorithm : 알고리즘
// Iterator : 반복자
// Adapter : 어뎁터
// Predicates : 옳고 그름을 판별하는 callable 함수 (bool)
// Concepts, Ranges, Span 에 대해 배울것
// 
// STL Sequence Containers
// array : 크기 변경 불가 배열
// vector : 동적 배열(한쪽으로만 확장 가능)
// deque(덱) : contiguous x 배열이 늘어나는 와중에 데이터 멀어짐
// forward_list : 연결리스트
// list : 이중연결리스트
// 
// STL Associative Containers -> 필요한 원소를 빠르게 찾으려고 사용
// set : key 와 value가 하나
// map : dictionary, key와 value가 연관되어 있음
// 
// STL Unordered Associative Containers -> 필요한 원소를 빠르게 찾으려고 사용
// Hashtable : key 값이 hash function 에 집어넣어 해당 bucket에서 값을 찾음
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	save("소스.cpp");
}

==================================================
소스.cpp2023-04-04 화요일 오후 8:13:38
==================================================
// 2023. 4. 3 월										(5주 2일)
//---------------------------------------------------------------------------
// STL 시작 - 표준문서(컨테이너), cppreference에서 컨테이너 공부해 보기
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

// Containers are object that store other objects

//--------
int main()
//--------
{
	array<String, 3> a;					// array안에 array 담을 수 있음 ex) array< array<String,3>, 100> a;

	save("소스.cpp");
}

==================================================
소스.cpp2023-04-04 화요일 오후 8:34:31
==================================================
// 2023. 4. 3 월										(5주 2일)
//---------------------------------------------------------------------------
// Sequence container - array
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	array<int, 10> a{ 1, 3, 5, 7 ,9 ,2, 4, 6, 8, 10 };

	// STL의 컨테이너의 원소에 access
	// 모든 값을 출력하기
	array<int, 10>::iterator p = a.begin();		// p는 포인터와 유사, 포인터는 x
	while (p != a.end()){
		cout << *p << endl;
		++p;
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-04-04 화요일 오후 8:38:02
==================================================
// 2023. 4. 3 월										(5주 2일)
//---------------------------------------------------------------------------
// Sequence container - array
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	array<int, 10> a{ 1, 3, 5, 7 ,9 ,2, 4, 6, 8, 10 };	// list로 바꿔도 동일

	cout << sizeof(a) << endl;

	// STL의 컨테이너의 원소에 access
	// 모든 값을 출력하기
	array<int, 10>::iterator p = a.begin();		// p는 포인터와 유사, 반복자 타입(iterator), 포인터는 x
	
	for (auto i = a.begin(); i != a.end(); ++i) {		
		cout << *i << endl;
	}

	for (int i = 0; i < a.size(); ++i) {		
		cout << a[i] << endl;
	}

	for(int n : a){
	cout << n << endl;
	}

	save("소스.cpp");
}

==================================================
소스.cpp2023-04-04 화요일 오후 8:53:00
==================================================
// 2023. 4. 3 월										(5주 2일)
//---------------------------------------------------------------------------
// Sequence container - array
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	array<int, 10> a{ 1, 3, 5, 7 ,9 ,2, 4, 6, 8, 10 };	// list로 바꿔도 동일

	cout << sizeof(a) << endl;
	// STL의 컨테이너의 원소에 access
	// 모든 값을뒤에서부터 출력하기

	for (auto p = a.rbegin(); p != a.rend(); ++p) {		// 실행되는 이유는 p가 함수이기 때문, ++p는 p.operator++()랑 같은 말
		cout << *p << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

==================================================
소스.cpp2023-04-04 화요일 오후 9:06:07
==================================================
// 2023. 4. 3 월										(5주 2일)
//---------------------------------------------------------------------------
// Sequence container - array
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <array>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	
	extern bool 관찰;
	관찰 = true;
	// [문제] 파일 "소스.cpp"에 있는 30개를 a로 읽어라
	array<String, 30> a;

	ifstream in{ "소스.cpp" };
	if (!in) {
		cout << "\"소스.cpp\"를 열 수 없습니다" << endl;
		return 0;
	}

	for (int i = 0; i < 30; ++i) {
		in >> a[i];
	}

	// a의 길이 기준 오름차순으로 a를 정렬하라
	sort(a.begin(), a.end(), [](const String& a, auto& b) {
		return a.size() < b.size();
		});
	
	// a의 내용을 모두 출력
	for (cosnt String& s : a) {
		cout << s << endl;
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-04-04 화요일 오후 9:23:12
==================================================
// 2023. 4. 3 월										(5주 2일)
//---------------------------------------------------------------------------
// Sequence container - array
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	extern bool 관찰;
	
	// [문제] 키보드에서 입력한 int를 10개만 array를 사용하여 저장하라
	// 합계를 화면에 출력하라

	array<int, 10> a;

	for (int i = 0; i < a.size(); ++i) {
		cin >> a[i];
	}
	cin.clear();

	int sum = *a.begin();
	cout << *a.begin();
	for (auto i = a. begin() + 1; i != a.end(); ++i) {
		cout << " + " << *i;
		sum += *i;
	}
	cout << " = " << sum << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-04-06 목요일 오후 1:34:25
==================================================
// 2023. 4. 6 목										(6주 1일)
//---------------------------------------------------------------------------
// Sequence container
// array -> 크기 고정, contiguous
// vector -> dynamic array -> run-time 때 결정
// deque
// forward lst
// list
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	save("소스.cpp");
}

==================================================
소스.cpp2023-04-06 목요일 오후 1:57:48
==================================================
// 2023. 4. 6 목										(6주 1일)
//---------------------------------------------------------------------------
// Sequence container - vector
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	vector<int> v{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	
	// v의 모든 값을 출력한다
	// v에 20을 추가한다
	// v에 모든 값을 출력한다
	cout << "v의 원소 개수             - " << v.size() << endl;
	cout << "v가 담을 수 있는 원소 개수 - " << v.capacity() << endl;
	
	for (int i = 0; i < v.size(); ++i) {
		cout << v[i] << " ";
	}
	cout << sizeof(v);
	cout << endl;
	
	v.push_back(20);
	cout << endl;
	cout << "v의 원소 개수             - " << v.size() << endl;
	cout << "v가 담을 수 있는 원소 개수 - " << v.capacity() << endl;
	// vector는 담을수 있는 원소 개수가 1.5배씩 늘어남
	for (int i = 0; i < v.size(); ++i) {
		cout << v[i] << " ";
	}
	cout << sizeof(v);
	cout << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-04-06 목요일 오후 2:12:54
==================================================
// 2023. 4. 6 목										(6주 1일)
//---------------------------------------------------------------------------
// Sequence container - vector
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <vector>
#include <thread>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] vector가 메모리를 늘려가는 모습을 관찰한다
//--------
int main()
//--------
{
	save("소스.cpp");

	vector<int> v(100);
	cout << "v의 원소 수              - " << v.size() << endl;
	cout << "v가 담을 수 있는 원소 수 - " << v.capacity() << endl;
	cout << endl;

	size_t oldCapacity = v.capacity();

	while (1) {
		v.push_back(1);
		if (oldCapacity != v.capacity()) {
			cout << "v의 원소 수             - " << v.size() << endl;
			cout << "v가 담을 수 있는 원소 수 - " << v.capacity() << endl;
			cout << endl;
			oldCapacity = v.capacity();

			this_thread::sleep_for(5s);
		}
	}

	
}

==================================================
소스.cpp2023-04-06 목요일 오후 2:38:21
==================================================
// 2023. 4. 6 목										(6주 1일)
//---------------------------------------------------------------------------
// Sequence container - vector
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp" 의 단어를 모두 읽어 오름차순 정렬 후 화면에 출력하라

//--------
int main()
//--------
{
	vector<String> v;
	ifstream in{ "소스.cpp" };
	
	if (!in) {
		cout << "\"소스.cpp\"를 열 수 없습니다" << endl;
		return 0;
	}
	
	String s;
	while (in >> s) {
		v.push_back( s );
	}

	sort(v.begin(), v.end(), [](const String& a, const String& b) {
		return a.getString() < b.getString();
		});
		
	for (auto i = v.begin(); i < v.end(); ++i) {
		cout << *i << endl;
	}
	
	save("소스.cpp");
}


==================================================
소스.cpp2023-04-06 목요일 오후 2:40:42
==================================================
// 2023. 4. 6 목										(6주 1일)
//---------------------------------------------------------------------------
// Sequence container - vector
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp" 의 단어를 모두 읽어 오름차순 정렬 후 화면에 출력하라

//--------
int main()
//--------
{
	extern bool 관찰;
	관찰 = true;
	vector<String> v;
	v.reserve(500);
	ifstream in{ "소스.cpp" };
	
	if (!in) {
		cout << "\"소스.cpp\"를 열 수 없습니다" << endl;
		return 0;
	}
	
	String s;
	while (in >> s) {
		v.push_back( s );
	}

	sort(v.begin(), v.end(), [](const String& a, const String& b) {
		return a.getString() < b.getString();
		});
		
	for (auto i = v.begin(); i < v.end(); ++i) {
		cout << *i << endl;
	}
	
	save("소스.cpp");
}

==================================================
소스.cpp2023-04-06 목요일 오후 2:49:09
==================================================
// 2023. 4. 6 목										(6주 1일)
//---------------------------------------------------------------------------
// Sequence container - vector
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <vector>
#include <numeric>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] 키보드에서 int를 입력받아 합계와 평균을 출력하라

//--------
int main()
//--------
{
	cout << "숫자를 입력하면 합계와 평균을 알려줍니다" << endl;

	int num;
	vector<int> v;
	while (cin >> num) {		
		v.push_back(num);
	}

	// 합계와 평균

	int sum = accumulate(v.begin(), v.end(), 0);
	cout << "합계 - " << sum << ", 평균 - " << (double)sum / v.size() << endl;
	
	save("소스.cpp");
}

==================================================
소스.cpp2023-04-06 목요일 오후 3:00:58
==================================================
// 2023. 4. 6 목										(6주 1일)
//---------------------------------------------------------------------------
// Sequence container - vector
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] 키보드에서 단어를 입력받아 오름차순 정렬한 후 출력하라

//--------
int main()
//--------
{
	String s;
	vector<String> v{ istream_iterator<String>{cin}, {} };	// cin으로 입력받는 String의 반복자로부터 끝까지 배열에 넣음
	
	sort(v.begin(), v.end(), [](auto& a, auto& b) {			// auto는 쓰기엔 편하지만 가급적 원본 자료형을 사용하는게 좋음
		return a.getString() < b.getString();
		});

	cout << "정렬된 문자 - ";
	for (auto& a : v) {
		cout << a << " ";
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-04-06 목요일 오후 3:07:47
==================================================
// 2023. 4. 6 목										(6주 1일)
//---------------------------------------------------------------------------
// Sequence container - vector
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp"의 글자(공백제외)를 모두 읽어 오름차순 정렬 후 출력하라

//--------
int main()
//--------
{
	ifstream in{ "소스.cpp" };

	vector<char> v{ istream_iterator<char>{in}, {} };
	
	sort(v.begin(), v.end());

	for (char c : v) {
		cout << c;
	}
	cout << endl;

	save("소스.cpp");
}

==================================================
소스.cpp2023-04-09 일요일 오후 3:53:19
==================================================
// 2023. 4. 6 목										(6주 1일)
//---------------------------------------------------------------------------
// Sequence container - vector
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	extern bool 관찰;
	관찰 = true;
	vector<String> v{ "123", "abcde", "7890" };

	// 메모리 그림으로 그릴수 있나
	save("소스.cpp");
}

==================================================
소스.cpp2023-04-10 월요일 오후 2:26:16
==================================================
// 2023. 4. 10 목										(6주 2일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
// Sequence container - vector
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	extern bool 관찰;
	관찰 = true;
	vector<String> v{ "123", "abcde", "7890" };

	// 메모리 그림으로 그릴수 있나
	save("소스.cpp");
}


==================================================
소스.cpp2023-04-10 월요일 오후 2:25:39
==================================================
// 2023. 4. 10 목										(6주 2일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
// Sequence container - vector
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	extern bool 관찰;
	관찰 = true;
	vector<String> v;
	cout << "원소 수 - " << v.size() << endl;
	cout << "data    - " << v.data() << endl;
	cout << "용량    - " << v.capacity() << endl;
	v.push_back("4월24일");
	
	v.push_back("중간시험");
	관찰 = false;
	// 메모리 그림으로 그릴수 있나
	
	save("소스.cpp");
}



==================================================
소스.cpp2023-04-10 월요일 오후 2:58:19
==================================================
// 2023. 4. 10 목										(6주 2일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
// Sequence container - vector
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	extern bool 관찰;
	관찰 = true;
	vector<String> v;
	v.reserve(3);

	v.emplace_back("4월24일");
	v.emplace_back("중간시험");
	
	// int 는 컴파일러가 알아서 그 자리에 만들기 때문에 emplace_back 해도 차이가 x

	// pushback 대신에 emplace_back을 사용하여 원하는 자리에 객체를 생성 -> v[1], v[2]
	// emplace_back에 "4월24일" 대신 String"4월24일"을 만들면 객체 생성후 이동생성하기 때문에 pushback이랑 다를 바 없음
	// -> emplace_back을 인자만을 전달함
	// 메모리 그림으로 그릴수 있나
	save("소스.cpp");
}


==================================================
소스.cpp2023-04-10 월요일 오후 3:16:06
==================================================
// 2023. 4. 10 목										(6주 2일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
// Sequence container - vector
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	extern bool 관찰;

	vector<String> v{"1", "12", "123"};

	관찰 = true;

	// v를 길이기준 내림차순으로 정렬하라

	// [7] 이동생성에서 temp 임시 객체 생성, 이동 할당 연산자로 원소 위치를 바꾸고 temp 소멸
	// sort 과정에서 문제가 발생할 수도 있기 때문에 v가 만들어 질때 복사생성으로 만들어져서 안정성을 보장한다
	sort(v.begin(), v.end(), [](const String& a, const String& b) {
		return a.size() > b.size();
		});
	관찰 = false;
	// 출력하라
	for (const String& i : v) {
		cout << i << endl;
	}
	save("소스.cpp");
}


==================================================
소스.cpp2023-04-10 월요일 오후 3:20:02
==================================================
// 2023. 4. 10 목										(6주 2일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
// Sequence container - vector
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	extern bool 관찰;

	vector<String> v;

	관찰 = true;
	v.push_back("123");
	v.push_back("abc");
	관찰 = false;

	// noexcept을 붙여줘서 만들어 주면 복사생성이 아닌 이동생성으로 만듬
	// 출력하라
	for (const String& i : v) {
		cout << i << endl;
	}
	save("소스.cpp");
}


==================================================
소스.cpp2023-04-13 목요일 오후 2:16:16
==================================================
// 2023. 4. 13 목										(7주 1일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// Sequence container - vector
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <filesystem>	// C++17
#include <algorithm>
#include <array>
#include <string>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp"의 영문자만 (대문자는 소문자로 바꿔) 개수를 세라
// 각 문자의 개수를 다음과 같이 출력하라
// a - 10
// b -3
// ~
// z- 1

//--------
int main()
//--------
{
	ifstream in{ "소스.cpp" };
	array<int, 26> alphaNum{};

	if (!in) {
		return 0;
	}

	char c;
	while (in >> c) {
		if (isalpha(c)) {
			++alphaNum[tolower(c) - 'a'];
		}
	}

	for (int i = 0; i < alphaNum.size(); ++i) {
		cout << static_cast<char>('a' + i) << " - " << alphaNum[i] << endl;
	}

	save("소스.cpp");
}


==================================================
소스.cpp2023-04-13 목요일 오후 2:43:27
==================================================
// 2023. 4. 13 목										(7주 1일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// Sequence container - vector
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	vector<int> v{ 1, 2, 3, 4, 5 };

	// [문제] v에서 3을 지워라 -> {1, 2, 4, 5}
	// 알고리즘 remove를 사용하면 된다

	vector<int>::iterator p = remove(v.begin(), v.end(), 3); 
	
	// 실제 size 조정은 벡터만 할 수 있다
	v.erase(p, v.end());

	for (int i = 0; i < v.size(); ++i) {
		cout << v[i] << ' ';
	}
	cout << endl;
	
	save("소스.cpp");
}


==================================================
소스.cpp2023-04-13 목요일 오후 2:58:44
==================================================
// 2023. 4. 13 목										(7주 1일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// Sequence container - vector
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	// [문제] v에서 짝수를 제거하라
	// remove_if 함수를 사용하면 된다
	// erase-remove idiom(숙어)
	// Predicate : 조건자

	auto p = remove_if(v.begin(), v.end(), [](int n) {
		return !(n & 1);		// 마지막 비트가 1이 아니면 remove
		});
	v.erase(p, v.end());

	for (int n : v) {
		cout << n << " ";
	}
	cout << endl;
	save("소스.cpp");
}


==================================================
소스.cpp2023-04-13 목요일 오후 3:04:16
==================================================
// 2023. 4. 13 목										(7주 1일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// Sequence container - vector
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	// [문제] v에서 짝수를 제거하라
	// remove_if 함수를 사용하면 된다
	// erase-remove idiom(숙어) ---> C++20부터는 전역함수 erase_if를 사용
	// Predicate : 조건자

	erase_if(v, [](int n) {
		return !(n & 1);		// 마지막 비트가 1이 아니면 remove
		});

	for (int n : v) {
		cout << n << " ";
	}
	cout << endl;
	save("소스.cpp");
}


==================================================
소스.cpp2023-04-17 월요일 오후 1:48:26
==================================================
// 2023. 4. 17 목										(7주 2일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// Sequence container - vector
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	vector<String> v{"1", "2", "3", "4", "5"};
	
	// [문제] v에서 3을 제거하라
	erase(v, "3");

	for (String& n : v) {
		cout << n << " ";
	}
	cout << endl;
	save("소스.cpp");
}


==================================================
소스.cpp2023-04-17 월요일 오후 2:06:39
==================================================
// 2023. 4. 17 목										(7주 2일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// Sequence container - vector
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	vector<String> v{"1", "22", "4444", "55555"};
	
	// [문제] v의 "2" 와 "4" 사이에 "333" 을 삽입(insert)하라

	관찰 = true;
	v.insert(v.begin() + 2, "333");
	관찰 = false;
	for (String& s : v) {
		cout << s << " ";
	}
	cout << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-04-17 월요일 오후 2:23:03
==================================================
// 2023. 4. 17 목										(7주 2일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// Sequence container - vector
// 1. 공간을 마련하고 사용 - reserve()
// 2. push_back 보다 emplace_back을 사용
// 3. 중간에서 원소를 자주 삽입/삭제한다면 다른 컨테이너를 사용하라
//===========================================================================
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	list<String> v{"1", "22", "4444", "55555"};
	
	// [문제] v의 "2" 와 "4" 사이에 "333" 을 삽입(insert)하라
	// vector로는 효율이 안좋기 때문에 중간 삽입에 적합한 자료형인 list를 사용
	auto p = v.begin();
	++p;
	++p;
	관찰 = true;
	// insert 보다 그 자리에 넣는 emplace를 사용하여 효율이 더 좋아짐
	v.emplace(p, "333");	
	관찰 = false;

	for (String& s : v) {
		cout << s << " ";
	}
	cout << endl;
	save("소스.cpp");
}


==================================================
소스.cpp2023-04-17 월요일 오후 2:39:22
==================================================
// 2023. 4. 17 목										(7주 2일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// Sequence container - deque
//===========================================================================
#include <iostream>
#include <deque>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	deque<int> d{1, 2, 3, 4, 5};
	
	// d의 앞에 0을 뒤에 6을 추가하라
	d.push_front(0);
	d.push_back(6);

	// deque은 contiguous 자료형이 아닌데 돌아감
	for (int i = 0; i < d.size(); ++i) {
		cout << d[i] << " ";
	}
	cout << endl;

	save("소스.cpp");
}


==================================================
소스.cpp2023-04-17 월요일 오후 2:44:57
==================================================
// 2023. 4. 17 목										(7주 2일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// Sequence container - deque
//===========================================================================
#include <iostream>
#include <deque>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	deque<int> d{0, 1, 2, 3, 4, 5, 6};
	
	for (int i = 0; i < d.size(); ++i) {
		cout << addressof(d[i]) << " ";
	}


	save("소스.cpp");
}


==================================================
소스.cpp2023-04-17 월요일 오후 2:47:34
==================================================
// 2023. 4. 17 목										(7주 2일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// Sequence container - deque
//===========================================================================
#include <iostream>
#include <deque>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	deque<String> d{ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" };
	
	for (int i = 0; i < d.size(); ++i) {
		cout << addressof(d[i]) << endl;
	}


	save("소스.cpp");
}


==================================================
소스.cpp2023-04-17 월요일 오후 3:04:59
==================================================
// 2023. 4. 17 목										(7주 2일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// Sequence container - deque
// - vector와 list의 중간형태인 자료구조
//===========================================================================
#include <iostream>
#include <deque>
#include <vector>
#include <list>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] 어느 컨테이너가 더 많은 int를 담을 수 있는가
// x86 모드에서 실행

//--------
int main()
//--------
{
	// vector<int> v;		// 최대원소수 - 1'3621'6567
	// deque<int> v;		// 최대원소수 - 2'6843'5452
	// list<int> v;		// 최대원소수 - 8400'5109
	
	try {
		while (true) {
			v.push_back(1);
		}
	}
	catch (exception& e) {
		cout << "메모리 부족 - " << e.what() << endl;
		cout << "v의 원소 수 - " << v.size() << endl;
	}

	save("소스.cpp");
}


==================================================
소스.cpp2023-04-17 월요일 오후 3:20:19
==================================================
// 2023. 4. 17 목										(7주 2일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험
//---------------------------------------------------------------------------
// Sequence container - list
//===========================================================================
#include <iostream>
#include <fstream>
#include <list>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] 파일 "리스트설명.txt" 의 단어를 list<String>으로 읽어와라
// 읽은 단어를 화면에 출력하라

//--------
int main()
//--------
{
	ifstream in{ "리스트설명.txt" };

	if (!in) {
		return 0;
	}

	list<String> cont;
	String s;

	while (in >> s) {
		cont.push_back(s);
	}
	for (String& s : cont) {
		cout << s << endl;
	}
	
	save("소스.cpp");
}


==================================================
소스.cpp2023-04-20 목요일 오후 1:46:32
==================================================
// 2023. 4. 20 월										(8주 1일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험(메모리 이해하기)
//---------------------------------------------------------------------------
// Sequence container - list
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <list>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	save("소스.cpp");

	vector<int> v{ 1,2,3,4,5 };
	
	while (true) {
		cout << "몇 번째 값을 알려드릴까요?" << endl;
		int num;
		cin >> num;
		try {
			cout << num << "번 값 - " << v.at(num) << endl;		// 예외인 경우에는 예외를 던짐(throw 1) 속도 느림, 메모리 잡아먹음
		}
		catch (exception& e) {
			cout << "잘못된 번호 - " << e.what() << endl;
			continue;
		}
	}
	
}


==================================================
소스.cpp2023-04-20 목요일 오후 1:49:52
==================================================
// 2023. 4. 20 월										(8주 1일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험(메모리 이해하기)
//---------------------------------------------------------------------------
// Sequence container - list
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <list>
#include <string>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	list<int> cont;

	cout << sizeof(list<int>) << endl;
	
	save("소스.cpp");
}

==================================================
소스.cpp2023-04-20 목요일 오후 2:00:56
==================================================
// 2023. 4. 20 월										(8주 1일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험(메모리 이해하기)
//---------------------------------------------------------------------------
// Sequence container - list
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <list>
#include <string>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	ifstream in{ "리스트설명.txt" };

	list<String> cont{ istream_iterator<String>{in}, {} };		// 파일을 돌아다니는 반복자, 고수준 입력 / 입력 스트림의 끝은 Default 생성
	cout << "모두" << cont.size() << "개의 단어를 읽었습니다" << endl;
	
	
	for (String& s : cont) {
		cout << s << endl;
	}
	save("소스.cpp");
}


==================================================
소스.cpp2023-04-20 목요일 오후 2:18:51
==================================================
// 2023. 4. 20 월										(8주 1일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험(메모리 이해하기)
//---------------------------------------------------------------------------
// Sequence container - list
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	extern bool 관찰;
	ifstream in{ "리스트설명.txt" };

	list<String> cont{ istream_iterator<String>{in}, {} };		// 파일을 돌아다니는 반복자, 고수준 입력 / 입력 스트림의 끝은 Default 생성
	cout << "모두" << cont.size() << "개의 단어를 읽었습니다" << endl;
	
	
	// [문제] cont를 오름차순으로 정렬하라
	// 문제 해결 1 : 벡터로 옮기기 -> 쓰레기
	// vector c{ cont.begin(), cont.end() };
	관찰 = true;
	cont.sort([](const String& a, const String& b) {		// list는 정렬이 vector보다 훨씬 빠름
		return a.getString() < b.getString();
		});
	관찰 = false;
	for (String& s : cont) {
		cout << s << endl;
	}
	/*for (auto p = cont.rbegin(); p != cont.rend(); ++p) {
		cout << *p << endl;
	}*/
	save("소스.cpp");
}


==================================================
소스.cpp2023-04-20 목요일 오후 2:31:00
==================================================
// 2023. 4. 20 월										(8주 1일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험(메모리 이해하기)
//---------------------------------------------------------------------------
// Sequence container - list
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	extern bool 관찰;
	ifstream in{ "리스트설명.txt" };

	list<String> cont{ istream_iterator<String>{in}, {} };		// 파일을 돌아다니는 반복자, 고수준 입력 / 입력 스트림의 끝은 Default 생성
	cout << "모두" << cont.size() << "개의 단어를 읽었습니다" << endl;
	
	
	// [문제] cont를 오름차순으로 정렬하라
	// 문제 해결 1 : 벡터로 옮기기 -> 쓰레기
	// vector c{ cont.begin(), cont.end() };

	관찰 = true;												// 관찰이 안되는 이유 : 할당연산자를 사용하지 않고 list 포인터를 바꾸면 바꾸기 때문 -> 효율이 좋음
	cont.sort([](const String& a, const String& b) {		// list는 정렬이 vector보다 훨씬 빠름
		return a.getString() < b.getString();
		});
	관찰 = false;

	for (String& s : cont) {
		cout << s << endl;
	}
	for (auto p = cont.rbegin(); p != cont.rend(); ++p) {
		cout << *p << endl;
	}
	save("소스.cpp");
}



==================================================
소스.cpp2023-04-20 목요일 오후 2:36:15
==================================================
// 2023. 4. 20 월										(8주 1일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험(메모리 이해하기)
//---------------------------------------------------------------------------
// Sequence container - list
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	extern bool 관찰;
	ifstream in{ "리스트설명.txt" };

	list<String> cont{ istream_iterator<String>{in}, {} };		
	cout << "모두" << cont.size() << "개의 단어를 읽었습니다" << endl;
	
	관찰 = true;												
	cont.sort([](const String& a, const String& b) {		
		return a.getString() < b.getString();
		});
	관찰 = false;
	
	// [문제] 역순으로 10개만 출력
	
	auto p = cont.rbegin();
	for (int i{}; i < 10; ++i) {
		cout << *p++ << endl;
	}

	// 다른 방법
	/*auto e = next(cont.rbegin(), 10);
	for (auto p = cont.rbegin(); p != e; ++p) {
		cout << *p << endl;
	}*/

	save("소스.cpp");
}


==================================================
소스.cpp2023-04-20 목요일 오후 2:38:16
==================================================
// 2023. 4. 20 월										(8주 1일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험(메모리 이해하기)
//---------------------------------------------------------------------------
// Sequence container - list
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	extern bool 관찰;
	ifstream in{ "리스트설명.txt" };

	list<String> cont{ istream_iterator<String>{in}, {} };		
	cout << "모두" << cont.size() << "개의 단어를 읽었습니다" << endl;
	
	관찰 = true;												
	cont.sort([](const String& a, const String& b) {		
		return a.getString() < b.getString();
		});
	관찰 = false;
	
	// [문제] 마지막 10개만 출력
	for (auto p = next(cont.begin(), cont.size() - 10); p != cont.end(); ++p) {
		cout << *p << endl;
	}

	/*for (String& s : cont | views::drop(cont.size() - 10)) {
		cout << s << endl;
	}*/

	save("소스.cpp");
}


==================================================
소스.cpp2023-04-20 목요일 오후 2:46:13
==================================================
// 2023. 4. 20 월										(8주 1일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험(메모리 이해하기)
//---------------------------------------------------------------------------
// Sequence container - list
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	extern bool 관찰;
	ifstream in{ "리스트설명.txt" };

	list<String> cont{ istream_iterator<String>{in}, {} };	

	cout << "모두" << cont.size() << "개의 단어를 읽었습니다" << endl;
	
	cont.sort([](const String& a, const String& b) {		
		return a.getString() < b.getString();
		});

	관찰 = true;
	cont.unique();			// 겹치는 문자 삭제
	관찰 = false;
	
	for (String& s : cont) {
		cout << s << endl;
	}
	save("소스.cpp");
	
}


==================================================
소스.cpp2023-04-20 목요일 오후 3:03:36
==================================================
// 2023. 4. 20 월										(8주 1일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험(메모리 이해하기)
//---------------------------------------------------------------------------
// Sequence container - list
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	save("소스.cpp");
	extern bool 관찰;
	ifstream in{ "리스트설명.txt" };

	list<String> cont{ istream_iterator<String>{in}, {} };	

	cout << "모두" << cont.size() << "개의 단어를 읽었습니다" << endl;

	// [문제] 단어를 입력받아서 cont에 있는 단어인지?
	// 그렇다면 몇 번째 단어인지 출력하라
	// find는 찾으면 바로 반환 -> 같은 문자 반환 x
	while (true) {
		cout << "찾을 단어를 입력하시오: " << endl;
		String s;
		cin >> s;

		auto p = find(cont.begin(), cont.end(), s);
		if (p == cont.end()) {
			cout << s << " 는 없는 단어입니다" << endl;
			continue;
		}
		cout << s << " 는 " << distance(cont.begin(), p) + 1 << "번째 있습니다" << endl;
	}
	
	
}


==================================================
소스.cpp2023-04-20 목요일 오후 3:09:52
==================================================
// 2023. 4. 20 월										(8주 1일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험(메모리 이해하기)
//---------------------------------------------------------------------------
// Sequence container - list
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	
	extern bool 관찰;
	ifstream in{ "리스트설명.txt" };

	list<String> cont{ istream_iterator<String>{in}, {} };	

	cout << "모두" << cont.size() << "개의 단어를 읽었습니다" << endl;

	// [문제] 길이가 7인 단어가 몇 개인지 출력하라
	// 답지에도 몇 개인지 써라
	
	/*int cnt{};
	for (String& s : cont) {
		if (s.size() == 7) {
			++cnt;
		}
	}
	cout << "길이 7인 단어의 수 - " << cnt << endl;	*/	// 이렇게 하면 점수 x


	auto cnt = count_if(cont.begin(), cont.end(), [](const String& s) {
		return s.size() == 7;
		});
	cout << "길이 7인 단어의 수 - " << cnt << endl;
	save("소스.cpp");
	
}


==================================================
소스.cpp2023-04-20 목요일 오후 3:16:51
==================================================
// 2023. 4. 20 월										(8주 1일)
//---------------------------------------------------------------------------
// 4월 24일 월(8주 2일) - 중간시험(메모리 이해하기)
//---------------------------------------------------------------------------
// Sequence container - list
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	ifstream in{ "리스트설명.txt" };

	list<String> cont{ istream_iterator<String>{in}, {} };	

	cout << "모두" << cont.size() << "개의 단어를 읽었습니다" << endl;

	// [문제] 길이가 7인 String을 "길이7.txt"에 저장하라
	// 한 줄에 String 한 개를 저장하라
	ofstream out{ "길이7.txt" };

	for (String& s : cont) {
		if (s.size() == 7) {
			out << s << endl;
		}
	}

	save("소스.cpp");
}


==================================================
소스.cpp2023-04-27 목요일 오후 2:34:16
==================================================
#include <iostream>
#include <fstream>
#include <format>
#include <filesystem>
#include <string>
#include <vector>
#include <algorithm>
#include <ranges>
#include "save.h"
using namespace std;


//------------ 주 의 ------------
// namespace std를 사용하였다.
// include 문장을 답지에 적을 필요없다.
// 실행되지 않는 코드를 적으면 감점한다
// 답이 맞더라도 효율 낮은 코드나 알고리즘을 사용하지 않은 코드는 감점한다.
// 프로그램 환경 - Release/x64, 프로젝트 속성 - 미리 보기 - 최신 C++ 초안의 기능(/std:c++latest)

// e-class에서 시험.zip을 다운 받은 후 시작한다.

// 각 문제를 해결하는데 필요한 코드( 멤버함수 포함 )를 답지에 적는다.
// 화면 출력을 적으라는 문제는 출력된 내용을 답지에 적는다.


//----------------------------------------------------------------------------
// class Test
//----------------------------------------------------------------------------
class Test {
	size_t id{};						// 랜덤 숫자
	string word{};						// 영문자, 공백이 없으며 최대 15글자

public:
	Test() = default;

	// num과 p에 저장된 int 값을 화면에 표시한다
	void show() const {
		cout << format("id:{:8}   word:{:15}", id, word) << endl;
	}

	void write(ostream& os) const {
		os.write((char*)this, sizeof(Test));
	//	os << id << " " << word << endl; -> 이렇게 코드를 쓰면 메모리 크기 가변
	}

	// [문제2] 답
	istream& read(ifstream& in) {
		return in.read((char*)this, sizeof(Test));
	}

	string& getString() {
		return word;
	}

	string getString() const {
		return word;
	}

	size_t getid() const {
		return id;
	}

	friend istream& operator>>(istream& is, Test& t) {
		return is.read((char*)&t, sizeof(Test));
	}
};

void deleteZ(vector<Test>& v);

void deleteZ(vector<Test>& v) {
	for (Test& t : v) {
		//erase(t.getString(), 'z');
		string& str = t.getString();
		auto p = remove(str.begin(), str.end(), 'z');
		str.erase(p, str.end());
	}
}

//---------
int main()
//---------
{
	save("소스.cpp");
	// "TEST 객체" 파일(바이너리 모드)에 Test 객체를 write() 멤버함수로 기록하였다.  
	// 파일에는 몇 개인지 모르는 Test 객체가 저장되어 있다.

	string fileName{ "Test 객체"s };

	ifstream in{ fileName, ios::binary };

	if (!in) {
		cout << fileName << " 파일을 열 수 없습니다" << endl;
		exit(0);
	}

	size_t fileSize = filesystem::file_size(fileName);
	cout << "파일 \"" << fileName << "\"의 크기 - " << fileSize << " 바이트" << endl;

	// [문제 1] 출력된 파일 크기를 보고 저장된 객체의 수를 알 수 있는지를 
	// "예/아니오"로 답하고 그렇게 답한 이유를 설명하라.						(10)

	// 예
	// wirte 함수를 보면 객체 그대로 binary 모드로 저장했기 때문
	
	// [문제 2] 파일을 읽어 객체를 컨테이너에 저장하라.							
	// 읽은 객체의 개수를 출력하고, 마지막 객체의 show()를 호출하라.
	// 화면에 출력된 내용을 답지에도 적어라.									(30)(저장관련코드:20, 출력코드와 출력: 10) 

	// 객체가 이미 있기 때문에 emplace_back이 의미없음
	size_t size = fileSize / sizeof(Test);
	vector<Test> v;
	//v.reserve(size);
	
	Test t;

	for (int i{}; i < size; ++i) {
		t.read(in);
		v.emplace_back(t);
	}

	//while (/*t.read(in)*/in >> t) {
	//	v.emplace_back(t);
	//}

	//in.read((char*)v.data(), size);
	cout << "컴테이너의 원소 수(읽은 수) - " << v.size() << endl;
	cout << "마지막 원소의 출력값" << endl;
	v.back().show();

	// (확인) 처음과 다음 객체의 show()를 호출한 결과는 다음과 같다.
	// id:  511803   word : zvrkmetlqhubzlq
	// id:   18649   word : ohjdt

	// [문제 3] 함수 deleteZ()는 [문제 2]에서 사용한 컨테이너를 인자로 받아
	// 컨테이너에 저장된 Test 객체의 word의 문자 중 소문자 'z'를 삭제하는 함수이다.
	// 이 함수를 선언하고 정의한 후 호출하라.									(35)(선언:5, 함수정의와 관련 코드:30)


	// (참고) string은 begin()과 end()를 제공하며 글자는 contiguous memory에 저장된다

	// (참고) 컨테이너 이름이 x라면 deleteZ(x); 와 같이 호출한다.

	// (확인) 'z'를 삭제한 후 처음과 다음 객체의 show()를 호출한 결과는 다음과 같다.
	// id:  511803   word : vrkmetlqhublq
	// id :  18649   word : ohjdt

	deleteZ(v);

	// [문제 4] 컨테이너에 저장한 Test 객체를 word 오름차순으로 정렬하고  
	// 제일 마지막 객체의 show()를 호출하라.
	// 화면에 출력된 결과를 답지에 적어라.										(20)(코드:15, 출력:5)

	sort(v.begin(), v.end(), [](const Test& a, const Test& b) {
		return a.getString() < b.getString();
		});

	cout << "정렬 후 마지막 원소" << endl;
	v.back().show();

	// [문제 5] 컨테이너에 저장된 Test 객체 중 id 값이 같은 객체는 하나 만 남기고 다 삭제하라.
	// 삭제 후 컨테이너에 남은 Test 객체의 수를 출력하고 결과를 답지에 적어라.	(25)(관련 코드:20, 출력:5)

	sort(v.begin(), v.end(), [](const Test& a, const Test& b) {
		return a.getid() < b.getid();
		});

	auto p = unique(v.begin(), v.end(), [](const Test& a, const Test& b) {
		return a.getid() == b.getid();
		});
	v.erase(p, v.end());

	cout << "unique 후 v 의 원소 수 - " << v.size() << endl;

}
===============================================================================================================================================================
===============================================================================================================================================================
===============================================================================================================================================================
===============================================================================================================================================================
===============================================================================================================================================================
===============================================================================================================================================================
===============================================================================================================================================================
===============================================================================================================================================================
===============================================================================================================================================================
기말고사 범위
==================================================
소스.cpp2023-04-27 목요일 오후 2:53:58
==================================================
#include <iostream>
#include "save.h"
using namespace std;

// STL
// container
// 1. Sequence
//		array	}	T[n]	string	}-- Contiguous / span, mdspan
//		vector	}-- Random access	}
//		duque	}
//		list
//		forward list
// 2. Associative
// 3. Unordered Associative
// Iterator
// Algorithm

//---------
int main()
//---------
{
	save("소스.cpp");
	
}

==================================================
소스.cpp2023-04-27 목요일 오후 2:59:07
==================================================
// 2023. 4. 27 월										(9주 1일)
//---------------------------------------------------------------------------
// Sequence container - list
//===========================================================================
#include <iostream>
#include <list>
#include "save.h"
#include "String.h"
using namespace std;

//--------
int main()
//--------
{
	list<int> cont1{ 7, 3, 5, 9, 1 };
	list<int> cont2{ 8, 2, 6, 4, 0 };

	cont1.sort();
	cont2.sort();

	// merge하면 합쳐진 원본만 남음 -> 복사생성으로 합치치 x
	cont1.merge(cont2);

	for (int n : cont1) {
		cout << n << " ";
	}
	cout << endl;
	
	for (int n : cont2) {
		cout << n << " ";
	}
	cout << endl;

	save("소스.cpp");
}

==================================================
소스.cpp2023-05-01 월요일 오후 1:58:01
==================================================
// 2023. 5. 1 월										(9주 2일)
//---------------------------------------------------------------------------
// Span, Mdspan(C++23)
// 
//		  { T[N]
// Span - { array<T, N>		==> contiguous memory
//		  { vector<T>
//		  { string		
// 
//				 { void(*p)(); - 함수 포인터
// callable type { function object -> operator()()
//				 { [](){};
//
//===========================================================================
#include <iostream>
#include <span>
#include <vector>
#include <list>
#include "save.h"
#include "String.h"
using namespace std;

void print(span<int>);	// []는 *로 collapse 된다
						// 여기서 span은 시작번지와 개수를 가짐

void print(span<int> cn) {
	for (int num : cn) {
		cout << num << " ";
	}
	cout << endl;
}

//--------
int main()
//--------
{
	int a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	print(a);	// 화면에 a의 모든 값을 출력하라

	vector<int> v( 10, 333 );
	print(v);
	
	save("소스.cpp");
}

==================================================
소스.cpp2023-05-01 월요일 오후 2:56:36
==================================================
// 2023. 5. 1 월										(9주 2일)
//---------------------------------------------------------------------------
// 반복자(iterator) - 포인터를 일반화 한 것이 반복자다
// container - 객체를 저장하는 객체
// 6가지 종류(category)로 나뉜다
// - 입력/출력/전진(전방향)/양방향(전후진)/랜덤엑세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// 기초 동작: *, ++, =
//===========================================================================
#include <iostream>
#include <iterator>
#include "save.h"
#include "String.h"
using namespace std;


//--------
int main()
//--------
{
	// 반복자는 클래스 객체이다. 할 수 있는 동작을 알아본다
	
	// 출력반복자 어댑터
	ostream_iterator<char> p{ cout };	// 선언할때 출력스트림을 지정해줘야함


	*p = 'a';
	++p;

	// 같은 의미

	(p.operator*()).operator=('a');
	p.operator++();

	// 그런데 operator* 와 operator++은 실질적으로 아무일도 안함 -> dereference 역참조

	save("소스.cpp");
}

==================================================
소스.cpp2023-05-04 목요일 오후 1:48:44
==================================================
// 2023. 5. 4 목										(10주 1일)
//---------------------------------------------------------------------------
// 반복자(iterator) - 포인터를 일반화 한 것이 반복자다
// container - 객체를 저장하는 객체
// 6가지 종류(category)로 나뉜다
// - 입력/출력/전진(전방향)/양방향(전후진)/랜덤엑세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// 기초 동작: *, ++, =
//===========================================================================
#include <iostream>
#include <iterator>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] 함수 f()는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력한다.
// 전달된 인자가 원하는 타입인지 판단하는 - type_traits

template <class 반복자>
void f(반복자 iter) {
	// 반복자가 진짜 반복자인지?
	cout << typeid (반복자::iterator_category).name() << endl;
}

random_access_iterator_tag;
//--------
int main()
//--------
{
	vector<int> v;			// data structure
	auto p = v.begin();		// p는 v가 제공하는 반복자

	f(p);

	save("소스.cpp");
}

==================================================
소스.cpp2023-05-04 목요일 오후 1:55:39
==================================================
// 2023. 5. 4 목										(10주 1일)
//---------------------------------------------------------------------------
// 반복자(iterator) - 포인터를 일반화 한 것이 반복자다
// container - 객체를 저장하는 객체
// 6가지 종류(category)로 나뉜다
// - 입력/출력/전진(전방향)/양방향(전후진)/랜덤엑세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// 기초 동작: *, ++, =
//===========================================================================
#include <iostream>
#include <iterator>
#include <forward_list>
#include <list>
#include <deque>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] 함수 f()는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력한다.
// 전달된 인자가 원하는 타입인지 판단하는 - type_traits

template <class 반복자>
void f(반복자 iter) {
	// 반복자가 진짜 반복자인지?
	cout << typeid (반복자::iterator_category).name() << endl;
}

random_access_iterator_tag;
//--------
int main()
//--------
{
	f(istream_iterator<char>{cin});
	f(ostream_iterator<char>{cout});
	f(forward_list<char>{}.begin());
	f(list<int>::iterator{});
	f(deque<int>::const_iterator());
	f(vector<int>::iterator());

	save("소스.cpp");
}

==================================================
소스.cpp2023-05-04 목요일 오후 1:58:06
==================================================
// 2023. 5. 4 목										(10주 1일)
//---------------------------------------------------------------------------
// 반복자(iterator) - 포인터를 일반화 한 것이 반복자다
// container - 객체를 저장하는 객체
// 6가지 종류(category)로 나뉜다
// - 입력/출력/전진(전방향)/양방향(전후진)/랜덤엑세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// 기초 동작: *, ++, =
//===========================================================================
#include <iostream>
#include <iterator>
#include <forward_list>
#include <list>
#include <deque>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] 함수 f()는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력한다.
// 전달된 인자가 원하는 타입인지 판단하는 - type_traits

template <class 반복자>
void f(반복자 iter) {
	// 반복자가 진짜 반복자인지?
	cout << typeid (반복자::iterator_category).name() << endl;
	cout << typeid (반복자::iterator_concept).name() << endl;			// concept은 메모리가 contiguous한 클래스에서만 가능
}

random_access_iterator_tag;
//--------
int main()
//--------
{
	f(vector<int>::iterator());

	save("소스.cpp");
}

==================================================
소스.cpp2023-05-04 목요일 오후 2:13:15
==================================================
// 2023. 5. 4 월목									(10주 1일)
//---------------------------------------------------------------------------
// 반복자(iterator) - 포인터를 일반화 한 것이 반복자다
// container - 객체를 저장하는 객체
// 6가지 종류(category)로 나뉜다
// - 입력/출력/전진(전방향)/양방향(전후진)/랜덤엑세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// 기초 동작: *, ++, =
//===========================================================================
#include <iostream>
#include <iterator>
#include <forward_list>
#include <list>
#include <deque>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] 함수 f()는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력한다.
// 전달된 인자가 원하는 타입인지 판단하는 - type_traits

template <class 반복자>
void f(반복자 iter) {
	// 진짜 표준 iterator
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
}

//--------
int main()
//--------
{
	int* p;
	f(p);
	save("소스.cpp");
}

==================================================
소스.cpp2023-05-04 목요일 오후 2:40:09
==================================================
// 2023. 5. 4 목									(10주 1일)
//---------------------------------------------------------------------------
// 반복자(iterator) - 포인터를 일반화 한 것이 반복자다
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야함
//		begin(), end()
//===========================================================================
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "13579246810" };

	// begin(), end() 맴버함수 추가
	auto p = s.begin();
	for (auto p = s.begin(); p != s.end(); ++p) {
		cout << *p << " ";
	}
	cout << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-05-04 목요일 오후 2:41:21
==================================================
// 2023. 5. 4 목									(10주 1일)
//---------------------------------------------------------------------------
// 반복자(iterator) - 포인터를 일반화 한 것이 반복자다
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야함
//		begin(), end()
//===========================================================================
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "13579246810" };

	for (char c : s) {			// s에서 begin(), end()를 제공하기 때문에 이 range 문도 돌아감
		cout << c << " ";
	}
	cout << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-05-04 목요일 오후 2:55:00
==================================================
// 2023. 5. 4 목										(10주 1일)
//---------------------------------------------------------------------------
// 반복자(iterator) - 포인터를 일반화 한 것이 반복자다
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야함
//		begin(), end()
//===========================================================================
#include <iostream>
#include <algorithm>
#include <span>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "STL iterators" };

	// [문제] s를 역순으로 출력하라
	
	// 0점 짜리 답
	//char* p = s.end() - 1;
	//for (int i{}; i < s.size(); ++i) {
	//	cout << *p-- << " ";
	//}
	//cout << endl;

	// 알고리즘 함수를 이용 reverse
	//reverse(s.begin(), s.end());
	//for (char c : s) {
	//	cout << c << " ";
	//}
	//cout << endl;
	

	// conntiguous 한 자료형을 span으로 덮어씌워서 사용
	span<char> ss{ /*s*/ s.begin(), s.end()};

	for (auto p = ss.rbegin(); p != ss.rend(); ++p) {
		cout << *p << " ";
	}
	cout << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-05-08 월요일 오후 1:34:15
==================================================
// 2023. 5. 8 월										(10주 2일)
//---------------------------------------------------------------------------
// 반복자(iterator) - 포인터를 일반화 한 것이 반복자다
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야함
//		begin(), end()
//		rbegin(), rend() -> 반드시 class로 구형해야만 한다
//						반복자 adaptor - 반복자처럼 행동하는 객체
//===========================================================================
#include <iostream>
#include <algorithm>
#include <span>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "STL iterators" };

	// [문제] s를 역순으로 출력하라
	// 다음 문장이 그대로 실행되어야 한다
	// p가 클래스 객체일때만 가능
	span<char> ss{ s };
	s.rbegin();


	// rbegin(), rend() 추가
	// 반복자 사기꾼(iterator adaptor)
	for (auto p = s.rbegin(); p != s.rend(); ++p) {
		cout << *p << " ";
	}
	cout << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-05-08 월요일 오후 2:03:47
==================================================
// 2023. 5. 8 월										(10주 2일)
//---------------------------------------------------------------------------
// 반복자(iterator) - 포인터를 일반화 한 것이 반복자다
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야함
//		begin(), end()
//===========================================================================
#include <iostream>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "STL iterators" };

	// String이 제공하는 반복자의 종류는?
	// STL에서 반복자의 종류를 물어보는 5가지
	// 1. 값타입
	// 2. *
	// 3. &
	// 4. difference (데이터끼리 얼마나 떨어져있는지)
	// 5. category

	// class String_iterator 추가
	// begin 함수 필요
	for (char& c : s) {
		c = toupper(c);
	}

	for (char c : s) {
		cout << c << " ";
	}
	cout << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-05-08 월요일 오후 2:18:27
==================================================
// 2023. 5. 8 월										(10주 2일)
//---------------------------------------------------------------------------
// 반복자(iterator) - 포인터를 일반화 한 것이 반복자다
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야함
//		begin(), end()
//===========================================================================
#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;

template<class iter>
void f(iter a, iter b) {
	if (typeid(iter::iterator_category) == typeid(random_access_iterator_tag)) {
		cout << "랜덤억세스 반복자" << endl;
	}
	else {
		cout << "아니다" << endl;
	}
}
//--------
int main()
//--------
{
	String s{ "STL iterators" };

	// String이 제공하는 반복자의 종류는?
	cout << typeid(String_iterator::iterator_category).name() << endl;
	
	f(s.begin(), s.end());
	
	save("소스.cpp");
}

==================================================
소스.cpp2023-05-08 월요일 오후 3:00:16
==================================================
// 2023. 5. 8 월										(10주 2일)
//---------------------------------------------------------------------------
// 반복자(iterator) - 포인터를 일반화 한 것이 반복자다
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야함
//		begin(), end()
//===========================================================================
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	// lazy fox 문장
	String s{ "The quick brown fox jumps over the lazy dog" };

	// 연산자 오버로딩 코딩
	sort(s.begin(), s.end());

	cout << s << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-05-11 목요일 오후 1:46:54
==================================================
// 2023. 5. 11 월										(11주 1일)
//---------------------------------------------------------------------------
// 반복자(iterator)
//===========================================================================
#include <iostream>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	
	String s{ "The quick brown fox jumps over the lazy dog" };

	transform(s.begin(), s.end(), s.begin(), [](char c) {
		return toupper(c);
		});

	cout << s << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-05-11 목요일 오후 2:08:07
==================================================
// 2023. 5. 11 월										(11주 1일)
//---------------------------------------------------------------------------
// 반복자(iterator)
//===========================================================================
#include <iostream>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

template<class iter, class val>
iter my_find(iter begin, iter end, val v) {
	while (begin != end) {
		if (*begin == v) {
			return begin;
		}
		++begin;
	}
		return begin;
}
//--------
int main()
//--------
{
	save("소스.cpp");
	String s{ "The quick brown fox jumps over the lazy dog" };

	// [문제] 찾을 문자를 입력받아 있는지 없는지
	// 있다면 몇 번째 문자인지 출력하라.


	while (true) {
		cout << "찾을 문자는? ";
		char c;
		cin >> c;


		auto p = my_find(s.begin(), s.end(), c);
		if (p == s.end()) {
			cout << c << " - 없는 문자 << endl";
		}
		else {
			cout << distance(s.begin(), p) + 1 << " 위치에서 발견" << endl;
		}
	}
	
}

==================================================
소스.cpp2023-05-11 목요일 오후 2:10:38
==================================================
// 2023. 5. 11 월										(11주 1일)
//---------------------------------------------------------------------------
// 반복자(iterator)
//===========================================================================
#include <iostream>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

template<class iter, class val>
iter my_find(iter begin, iter end, val v) {
	while (begin != end) {
		if (*begin == v) {
			return begin;
		}
		++begin;
	}
		return begin;
}
//--------
int main()
//--------
{
	save("소스.cpp");
	String s{ "The quick brown fox jumps over 1231231 the lazy dog" };

	// [문제] s 중에 숫자가 있나 찾고 싶다
	auto p = find_if(s.begin(), s.end(), [](char c) {
		return isdigit(c);
		});
	if (p == s.end()) {
		cout << "숫자 없다" << endl;
	}
	else {
		cout << distance(s.begin(), p) + 1 << " 번째 문자는 숫자" << endl;
	}
}

==================================================
소스.cpp2023-05-11 목요일 오후 2:36:21
==================================================
// 2023. 5. 11 월										(11주 1일)
//---------------------------------------------------------------------------
// 반복자(iterator)
//===========================================================================
#include <iostream>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

template<class Iter, class Pred>
Iter my_find_if(Iter begin, Iter end, Pred pred) {
	while (begin != end) {
		if (pred(*begin)) {
			return begin;
		}
		++begin;
	}
	return end;
}

//--------
int main()
//--------
{
	
	String s{ "The quick brown fox jumps 123123 over the lazy dog" };

	// [문제] s 중에 숫자가 있나 찾고 싶다
	auto p = my_find_if(s.begin(), s.end(), [](char c) {
		return isdigit(c);
		});
	if (p == s.end()) {
		cout << "숫자 없다" << endl;
	}
	else {
		cout << distance(s.begin(), p) + 1 << " 번째 문자는 숫자" << endl;
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-05-11 목요일 오후 2:50:23
==================================================
// 2023. 5. 11 월										(11주 1일)
//---------------------------------------------------------------------------
// 반복자(iterator)
//===========================================================================
#include <iostream>
#include <algorithm>
#include <array>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

template<class InIter, class OutIter>
void my_copy(InIter begin, InIter end, OutIter out) {
	while (begin != end) {
		*out = *begin;
		++begin;
		++out;
	}
}

//--------
int main()
//--------
{
	
	String s{ "0123456789" };
	vector<char> v;
	v.reserve(s.size());	// reserve 했을 때 안되는 이유는 vector의 맴버변수인 원소수가 변하지 않았기 때문
	//array<char, 10> v;	// 여기에 접근하려면 반복자 inserter를 사용해야함

	my_copy(s.begin(), s.end(), v.begin());
	// v.begin() 대신 back_inserter()를 사용함 -> reserve도 안해줘도 되는 반복자 어댑터 그러나 이렇게 코딩하는 것은 추천X
	for (char c : v) {
		cout << c << " - ";
	}
	cout << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-05-11 목요일 오후 3:13:37
==================================================
// 2023. 5. 11 월										(11주 1일)
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include <set>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{	
	// String을 길이 오름차순으로 정렬하는 컨테이너
	// String.h, String.cpp에 operator< 추가
	set<String> s{ "2", "111", "33", "55555", "4444" };

	for (const String& s : s) {
		cout << s << endl;
	}
	save("소스.cpp");
}

==================================================
소스.cpp2023-05-15 월요일 오후 1:58:44
==================================================
// 2023. 5. 15 월										(11주 2일)
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// 
// set에 정렬기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다 - 길이순
// 2. struct less를 특수화한다 - 사전식
//===========================================================================
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// template 특수화 내가 직접 적는다 
template <>
struct less<String>{
	// 사전식 정렬
	bool operator()(const String& a, const String& b) const {
		return a.getString() < b.getString();
	}
};

//--------
int main()
//--------
{	
	// "소스.cpp" 를 s 에 저장
	
	ifstream in{ "소스.cpp" };

	set<String> s{ istream_iterator<String>{in}, {} };

	for (const String& s : s) {
		cout << s << endl;
	}

	save("소스.cpp");
}

==================================================
소스.cpp2023-05-15 월요일 오후 2:08:15
==================================================
// 2023. 5. 15 월										(11주 2일)
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// 
// set/map에 정렬기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다 - 길이순
// 2. struct less를 특수화한다 - 사전식
// 3. 호출가능객체를 직접 전달 - 영문자 우선순
//===========================================================================
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

struct 영문자우선{
	// 영문자우선정렬
	bool operator()(const String& a, const String& b) const {
		// 영영, 영X, X영, XX
		// begin, end가 const 함수가 아니기 때문에 const 함수로 새로 추가
		if (isalpha(*(a.begin()))) {
			if (isalpha(*(b.begin()))) {
				return true;
			}
			return true;
		}
	}
};

//--------
int main()
//--------
{	
	// "소스.cpp" 를 s 에 저장
	// 파티션 함수가 있음 -> sort로 만들면 0점 -> 연산량이 많음
	ifstream in{ "소스.cpp" };

	multiset<String, 영문자우선> s{istream_iterator<String>{in}, {}};

	for (const String& s : s) {
		cout << s << endl;
	}

	save("소스.cpp");
}

==================================================
소스.cpp2023-05-15 월요일 오후 2:18:37
==================================================
// 2023. 5. 15 월										(11주 2일)
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// 
// set/map에 정렬기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다 - 길이순
// 2. struct less를 특수화한다 - 사전식
// 3. 호출가능객체를 직접 전달 - 영문자 우선순
//===========================================================================
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{	
	// 이상한 나라의 앨리스.txt를 사전식으로 정렬
	
	ifstream in{ "이상한 나라의 앨리스.txt" };

	if (!in) {
		cout << "파일을 확인하세요" << endl;
		return 0;
	}

	// operator< 를 사전식 비교로 수정
	// multiset은 중복 허용
	multiset<String> s{ istream_iterator<String>{in}, {} };

	for (const String& s : s) {
		cout << s << endl;
	}
	cout << "단어 수 - " << s.size() << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-05-15 월요일 오후 2:41:33
==================================================
// 2023. 5. 15 월										(11주 2일)
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// 
// set/map에 정렬기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다 - 길이순
// 2. struct less를 특수화한다 - 사전식
// 3. 호출가능객체를 직접 전달 - 영문자 우선순
//===========================================================================
#include <iostream>
#include <set>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{	
	ifstream in{ "이상한 나라의 앨리스.txt" };
	set<String> s{ istream_iterator<String>{in}, {} };

	save("소스.cpp");

	// [문제] 사용자가 입력한 단어가 셋에 있는지 있다면 몇번째 단어인지 출력
	// 이렇게 하면 쓰레기
	while (true) {
		cout << "찾을 단어는? ";
		String word;
		cin >> word;

		auto p = find(s.begin(), s.end(), word);	// O(n)
		if (p != s.end()) {
			cout << distance(s.begin(), p) + 1 << "번째 단어입니다" << endl;
		}
		else {
			cout << "없는 단어 입니다" << endl;
		}
	}
}

==================================================
소스.cpp2023-05-15 월요일 오후 2:46:30
==================================================
// 2023. 5. 15 월										(11주 2일)
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// 
// set/map에 정렬기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다 - 길이순
// 2. struct less를 특수화한다 - 사전식
// 3. 호출가능객체를 직접 전달 - 영문자 우선순
//===========================================================================
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{	
	ifstream in{ "이상한 나라의 앨리스.txt" };
	set<String> s{ istream_iterator<String>{in}, {} };

	save("소스.cpp");

	// [문제] 사용자가 입력한 단어가 set에 있는지 있다면 몇번째 단어인지 출력
	while (true) {
		cout << "찾을 단어는? ";
		String word;
		cin >> word;

		// 맴버함수 활용
		auto p = s.find(word);
		if (p != s.end()) {
			cout << distance(s.begin(), p) + 1 << "번째 단어입니다" << endl;
		}
		else {
			cout << "없는 단어 입니다" << endl;
		}
	}
}

==================================================
소스.cpp2023-05-15 월요일 오후 3:06:31
==================================================
// 2023. 5. 15 월										(11주 2일)
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// 
// set/map에 정렬기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다 - 길이순
// 2. struct less를 특수화한다 - 사전식
// 3. 호출가능객체를 직접 전달 - 영문자 우선순
//===========================================================================
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{	
	ifstream in{ "이상한 나라의 앨리스.txt" };
	set<String> s{ istream_iterator<String>{in}, {} };

	save("소스.cpp");

	// [문제] 사용자가 입력한 문자가 포함된 단어를 모두 출력하라

	while (true) {
		cout << "문자를 입력하시오 ";
		char c;
		cin >> c;
		
		int count{};

		for (const String& str : s) {
			if (str.getString().contains(c)) {
				++count;
				cout << str << " ";
			}
		}
		cout << endl;
		cout << "문자개수 : " << count << endl;
	}

	
}

==================================================
소스.cpp2023-05-15 월요일 오후 10:29:58
==================================================
// 2023. 5. 15 월										(11주 2일)
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// 
// set/map에 정렬기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다 - 길이순
// 2. struct less를 특수화한다 - 사전식
// 3. 호출가능객체를 직접 전달 - 영문자 우선순
//===========================================================================
#include <iostream>
#include <set>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{	
	ifstream in{ "이상한 나라의 앨리스.txt" };
	set<String> s{ istream_iterator<String>{in}, {} };

	save("소스.cpp");

	// [문제] 사용자가 입력한 부분문자가 포함된 단어를 모두 출력하라

	while (true) {
		cout << "찾을 단어를 입력하시오 ";
		String word;
		cin >> word;
		
		for (const String& str : s) {
			if (s.contains(word)){
			}
		}
	}
}

==================================================
소스.cpp2023-05-18 목요일 오후 1:38:56
==================================================
// 2023. 5. 18 목										(12주 1일)
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// 
// set/map에 정렬기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다 - 길이순
// 2. struct less를 특수화한다 - 사전식
// 3. 호출가능객체를 직접 전달 - 영문자 우선순
//===========================================================================
#include <iostream>
#include <set>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	ifstream in{ "이상한 나라의 앨리스.txt" };
	set<String> s{ istream_iterator<String>{in}, {} };

	save("소스.cpp");
	cout << "단어 수 - " << s.size() << endl;
	// [문제] 사용자가 입력한 부분문자가 포함된 단어를 모두 출력하라
	// string의 맴버함수 contains 활용

	while (true) {
		cout << "찾을 단어를 입력하시오 ";
		String word;
		cin >> word;

		for (const String& str : s) {
			std::string temp = str.getString();
			if (temp.contains(word.getString())) {
				cout << str << " ";
			}
		}
		cout << endl;
	}
}

==================================================
소스.cpp2023-05-18 목요일 오후 1:52:47
==================================================
// 2023. 5. 18 목										(12주 1일)
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// 
// set/map에 정렬기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다 - 길이순
// 2. struct less를 특수화한다 - 사전식
// 3. 호출가능객체를 직접 전달 - 영문자 우선순
//===========================================================================
#include <iostream>
#include <set>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	ifstream in{ "이상한 나라의 앨리스.txt" };
	set<String> s{ istream_iterator<String>{in}, {} };

	save("소스.cpp");
	cout << "단어 수 - " << s.size() << endl;
	// [문제] 사용자가 입력한 부분문자가 포함된 단어를 모두 출력하라
	// 알고리즘 함수 search 활용

	while (true) {
		cout << "찾을 단어를 입력하시오 ";
		String word;
		cin >> word;
		// 알고리즘 함수 search가 이런 일을 한다
		for (const String& str : s) {
			auto p = search(str.begin(), str.end(), word.begin(), word.end());
			if (p != str.end()) {
				cout << str << " ";

			}
		}
		cout << endl;
	}
}

==================================================
소스.cpp2023-05-18 목요일 오후 2:07:29
==================================================
// 2023. 5. 18 목										(12주 1일)
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// 
// set/map에 정렬기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다 - 길이순
// 2. struct less를 특수화한다 - 사전식
// 3. 호출가능객체를 직접 전달 - 영문자 우선순
//===========================================================================
#include <iostream>
#include <set>
#include <fstream>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	ifstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> s{ istream_iterator<String>{in}, {} };

	save("소스.cpp");
	cout << "단어 수 - " << s.size() << endl;

	for (const String& s : s | views::drop(12000) | views::take(200)) {
		cout << s << endl;
	}
	// [문제] 사용자가 입력한 단어가 모두 몇 개인지 출력하라
	// 없으면 없다고 출력하라

	while (true) {
		cout << "찾을 단어를 입력하시오 ";
		String word;
		cin >> word;

		// multiset의 맴버함수 count로 갯수 세기
		auto a = s.count(word);
		int cnt{};
		if (cnt = a) {
			cout << word << "의 개수 - " << cnt << endl;
		}
		else {
			cout << word << "는 사용되지 않았습니다" << endl;
		}
		cout << endl;
	}	
}


==================================================
소스.cpp2023-05-18 목요일 오후 2:35:35
==================================================
// 2023. 5. 18 목										(12주 1일)
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// 
// set/map에 정렬기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다 - 길이순
// 2. struct less를 특수화한다 - 사전식
// 3. 호출가능객체를 직접 전달 - 영문자 우선순
//===========================================================================
#include <iostream>
#include <set>
#include <fstream>
#include <algorithm>
#include <ranges>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	ifstream in{ "이상한 나라의 앨리스.txt" };
	vector<String> s{ istream_iterator<String>{in}, {} };

	save("소스.cpp");
	cout << "단어 수 - " << s.size() << endl;

	// 벡터를 정렬
	sort(s.begin(), s.end());

	for (const String& s : s | views::drop(12000) | views::take(200)) {
		cout << s << endl;
	}

	// [문제] 사용자가 입력한 단어가 모두 몇 개인지 출력하라
	// 없으면 없다고 출력하라
	// 알고리즘 함수 equal_range 사용

	while (true) {
		cout << "찾을 단어를 입력하시오 ";
		String word;
		cin >> word;

		auto [하한선, 상한선] = equal_range(s.begin(), s.end(), word);
		
		int cnt = 상한선 - 하한선;
		cout << word << "의 수 - " << cnt << endl;
	}	
}


==================================================
소스.cpp2023-05-18 목요일 오후 2:59:29
==================================================
// 2023. 5. 18 목										(12주 1일)
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// map은 pair<key, value>를 원소로 갖는다.
//===========================================================================
#include <iostream>
#include <map>
#include <list>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// Kpop그룹과 멤버들을 map으로 관리
	// key 값은 변경금지 되어 있음 const
	map<String, list<String>> kpop
					{ {"아이브", {"원영", "유진", "레이"}} };
	kpop.insert( { "베이비몬스터", {"루카", "파리타", "아사"}} );
	
	for (auto [그룹이름, 멤버들] : kpop) {
		cout << 그룹이름 << " - ";
		for (const String& 멤버 : 멤버들) {
			cout << 멤버 << " ";
		}
		cout << endl;
	}

	// &가 붙어야 원본에서 추가 가능 없으면 복사
	list<String>& 멤버들 = kpop["아이브"];
	멤버들.insert(멤버들.begin(), { "리즈", "이서" });
	for (const String& s : 멤버들) {
		cout << s << " ";
	}


	save("소스.cpp");
	
}

==================================================
소스.cpp2023-05-18 목요일 오후 3:06:40
==================================================
// 2023. 5. 18 목										(12주 1일)
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// map은 pair<key, value>를 원소로 갖는다.
//===========================================================================
#include <iostream>
#include <map>
#include <list>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// Kpop그룹과 멤버들을 map으로 관리
	// key 값은 변경금지 되어 있음 const
	map<String, list<String>> kpop
					{ {"아이브", {"원영", "유진", "레이"}} };
	kpop.insert( { "베이비몬스터", {"루카", "파리타", "아사"}} );

	// &가 붙어야 원본에서 추가 가능 없으면 복사
	list<String>& 멤버들 = kpop["아이브"];
	멤버들.insert(멤버들.begin(), { "리즈", "이서" });
	
	// const인 노드 이름을 변경하는 기능추 - extract 멤버(C++17)
	// 노드를 추출해 와서 작업 후 다시 insert 해줘야 함

	auto handle = kpop.extract("아이브");
	handle.key() = "IVE";
	kpop.insert(move(handle));
	
	
	for (auto [그룹이름, 멤버들] : kpop) {
		cout << 그룹이름 << " - ";
		for (const String& 멤버 : 멤버들) {
			cout << 멤버 << " ";
		}
		cout << endl;
	}

	save("소스.cpp");
	
}


==================================================
소스.cpp2023-05-22 월요일 오후 1:36:00
==================================================
// 2023. 5. 22 월										(12주 2일)
// 13주 2일 5. 29 월요일 - 동영상 출석
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// map은 pair<key, value>를 원소로 갖는다.
//===========================================================================
#include <iostream>
#include <map>
#include <list>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{

	// [문제]소설에서 각 문자가 사용된 횟수를 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };

	if (!in) {
		cout << "파일을 찾을 수 없습니다" << endl;
		return 0;
	}

	map<char, int> cim;

	char c;
	while (in >> c) {
		cim[c]++;
	}

	// [문제] 많이 사용된 문자 순으로 출력하라
	for (auto [문자, 개수] : cim) {

		cout << 문자 << " - " << 개수 << endl;
		
	}

	save("소스.cpp");
	
}


==================================================
소스.cpp2023-05-22 월요일 오후 1:40:50
==================================================
// 2023. 5. 22 월										(12주 2일)
// 13주 2일 5. 29 월요일 - 동영상 출석
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// map은 pair<key, value>를 원소로 갖는다.
//===========================================================================
#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{

	// [문제]소설에서 각 문자가 사용된 횟수를 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };

	if (!in) {
		cout << "파일을 찾을 수 없습니다" << endl;
		return 0;
	}

	map<char, int> cim;

	// 소문자 출력
	char c;
	while (in >> c) {
		if (isalpha(c)) {
			cim[tolower(c)]++;
		}
	}

	// [문제] 많이 사용된 문자 순으로 출력하라
	for (auto [문자, 개수] : cim) {		// strutureed binding 

		cout << 문자 << " - " << 개수 << endl;
		
	}

	save("소스.cpp");
	
}

==================================================
소스.cpp2023-05-22 월요일 오후 1:44:20
==================================================
// 2023. 5. 22 월										(12주 2일)
// 13주 2일 5. 29 월요일 - 동영상 출석
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// map은 pair<key, value>를 원소로 갖는다.
//===========================================================================
#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{

	// [문제]소설에서 각 문자가 사용된 횟수를 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };

	if (!in) {
		cout << "파일을 찾을 수 없습니다" << endl;
		return 0;
	}

	map<char, int> cim;

	char c;
	while (in >> c) {
		if (isalpha(c)) {
			cim[tolower(c)]++;
		}
	}
	// cim의 원소를 vector로 복사
	vector< pair<char, int> > v{ cim.begin(), cim.end() };
	
	// 정렬하기
	sort(v.begin(), v.end(), [](const auto& a, const auto& b) {
		return a.second > b.second;
		});

	// [문제] 많이 사용된 문자 순으로 출력하라
	for (auto [문자, 개수] : v) {		// strutureed binding 

		cout << 문자 << " - " << 개수 << endl;
		
	}

	save("소스.cpp");
	
}


==================================================
소스.cpp2023-05-22 월요일 오후 1:59:49
==================================================
// 2023. 5. 22 월										(12주 2일)
// 13주 2일 5. 29 월요일 - 동영상 출석
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// map은 pair<key, value>를 원소로 갖는다.
//===========================================================================
#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	
	// [문제]소설에서 각 단어가 사용된 횟수기준 내림차순으로 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };

	if (!in) {
		cout << "파일을 찾을 수 없습니다" << endl;
		return 0;
	}

	map<String, int> Sim;

	String s;
	while (in >> s) {
		Sim[s]++;
	}

	multimap<int, String> iSm;
	
	for (auto [단어, 개수] : Sim) {
		//iSm.insert(pair<int, String>{개수, 단어});
		iSm.insert(make_pair(개수, 단어));			// 개수와 단어를 짝으로 자동으로 만들어 주는 함수
	}

	for (auto [개수, 단어] : iSm | views::reverse | views::take(200)) {
		cout << 단어 << " - " << 개수 << endl;
	}

	cout << "원소 수 - " << Sim.size() << endl;
	cout << "원소 수 - " << iSm.size() << endl;
	save("소스.cpp");
	
}


==================================================
소스.cpp2023-05-22 월요일 오후 2:15:18
==================================================
// 2023. 5. 22 월										(12주 2일)
// 13주 2일 5. 29 월요일 - 동영상 출석
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// Associative 컨테이너 - set/map : 원소의 같음을 equivalence로 평가
//									(동등성, 상등성)
// map은 pair<key, value>를 원소로 갖는다.
//===========================================================================
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uid(1, 99'999);

//--------
int main()
//--------
{
	
	// [문제] 숫자를 10구간으로 나눠 개수를 세서 출력하라
	// [0, 9999] - 
	// [10000, 19999] -
	// ~
	// [90000, 99999] -

	int a[10]{};

	for (int i{}; i < 100000'000; ++i) {
		int num = uid(dre);
		a[num / 10000]++;
	}

	for (int i{}; i < 10; ++i) {
		cout << "[" << 0 + i * 10000 << ", " << 9999 + i * 10000 << "] - " << a[i] << endl;
	}

	save("소스.cpp");
	
}


==================================================
소스.cpp2023-05-22 월요일 오후 2:59:18
==================================================
// 2023. 5. 22 월										(12주 2일)
// 13주 2일 5. 29 월요일 - 동영상 출석
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// Unordered Associative 컨테이너
// 순서가 없다는 것의 의미
// 메모리 구조를 이해해 본다
// String을 원소로 담으려면 hash 함수를 제공하면 된다
//===========================================================================
#include <iostream>
#include <unordered_set>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	unordered_multiset<int> us{ 1, 2, 3, 4 };

	save("소스.cpp");


	while(true) {
		for (int i{}; i < us.bucket_count(); ++i) {
			cout << "[" << i << "]";
			for (auto p = us.begin(i); p != us.end(i); ++p) {
				cout << " - " << *p;
			}
			cout << endl;
		}
		
		cout << "값을 입력하면 원소를 추가합니다";
		
		int num;
		cin >> num;
		us.insert(num);

	}
	// 동일한 원소를 추가하면 list의 형태로 같은 값을 추가함 
	// 새로운 원소는 hash에 의해 순서 없이 담아짐
	
}


==================================================
소스.cpp2023-05-22 월요일 오후 3:12:53
==================================================
// 2023. 5. 22 월										(12주 2일)
// 13주 2일 5. 29 월요일 - 동영상 출석
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// Unordered Associative 컨테이너
// 순서가 없다는 것의 의미
// 메모리 구조를 이해해 본다
// String을 원소로 담으려면 hash 함수를 제공하면 된다
//===========================================================================
#include <iostream>
#include <unordered_set>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

template <>
struct hash<String> {
	size_t operator()(const String& str) const {
		return hash<string>( )(str.getString());
	}
};

//--------
int main()
//--------
{
	unordered_multiset<String, hash<String>> us{ "C++", "STL", "Constainer", "iterator", "Algorithm"};

	save("소스.cpp");

	while(true) {
		for (int i{}; i < us.bucket_count(); ++i) {
			cout << "[" << i << "]";
			for (auto p = us.begin(i); p != us.end(i); ++p) {
				cout << " - " << *p;
			}
			cout << endl;
		}
		
		cout << "값을 입력하면 원소를 추가합니다";
		
		String s;
		cin >> s;
		us.insert(s);

	}
	// 동일한 원소를 추가하면 list의 형태로 같은 값을 추가함 
	// 새로운 원소는 hash에 의해 순서 없이 담아짐
	
}


==================================================
소스.cpp2023-05-22 월요일 오후 3:14:51
==================================================
// 2023. 5. 22 월										(12주 2일)
// 13주 2일 5. 29 월요일 - 동영상 출석
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// Unordered Associative 컨테이너
// 순서가 없다는 것의 의미
// 메모리 구조를 이해해 본다
// String을 원소로 담으려면 hash 함수를 제공하면 된다
//===========================================================================
#include <iostream>
#include <unordered_set>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

template <>
struct hash<String> {
	size_t operator()(const String& str) const {
		return hash<string>( )(str.getString());
	}
};

//--------
int main()
//--------
{
	unordered_multiset<String, hash<String>> us{ "C++", "STL", "Constainer", "iterator", "Algorithm"};

	save("소스.cpp");
	
	auto p = us.find("Algorithm");
	cout << *p << endl;
}


==================================================
소스.cpp2023-05-25 목요일 오후 2:15:02
==================================================
// 2023. 5. 25 목										(13주 1일)
// 13주 2일 5. 29 월요일 - 동영상 출석
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// 컨테이너들의 찾기 실력을 검증한다. int 천만개에서 int 만개를 찾는다
// vector				16.476685초
// set					 0.010442초
// unordered_set		 0.000305초
// sorted_vector		 0.002629초
// 
// set은 원소 추가나 삭제가 빈번하게 일어날 때 사용하면 좋음
// vector는 고정된 값에서 정렬후 특정 값을 찾을 때 사용하면 좋음
//===========================================================================
#include <iostream>
#include <random>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include <algorithm>
#include <chrono>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

array<int, 1000'0000> numbers;
array<int, 1'0000 > toFind;

default_random_engine dre;
uniform_int_distribution uid{ 1, 100'000'000 };


//--------
int main()
//--------
{
	for (int& num : numbers) {
		num = uid(dre);
	}

	for (int& num : toFind) {
		num = uid(dre);
	}

	{	// vector에서 찾기
		cout << "vector에 데이터 넣는 중..." << endl;
		vector<int> v{ numbers.begin(), numbers.end() };
		cout << "vector에서 찾는 중..." << endl;
		int cnt = 0;

		// 시간재기 시작
		auto start = chrono::steady_clock::now();
		for (int num : toFind) {
			if (v.end() != find(v.begin(), v.end(), num)) {
				cnt++;
			}
		}

		// 시간재기 끝
		auto end = chrono::steady_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::microseconds>(end - start).count();	// 시간간격 duration

		cout << endl;
		cout << "걸린 시간(us) - " << elapsedTime << endl;
		cout << "찾은 수       - " << cnt << endl;
		cout << endl << endl;
	}

	{	// set에서 찾기
		cout << "set에 데이터 넣는 중..." << endl;
		set<int> s{ numbers.begin(), numbers.end() };
		cout << "set에서 찾는 중..." << endl;
		int cnt = 0;

		// 시간재기 시작
		auto start = chrono::steady_clock::now();
		for (int num : toFind) {
			if (s.contains(num)) {
				cnt++;
			}
		}

		// 시간재기 끝
		auto end = chrono::steady_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::microseconds>(end - start).count();	// 시간간격 duration

		cout << endl;
		cout << "걸린 시간(us) - " << elapsedTime << endl;
		cout << "찾은 수       - " << cnt << endl;
		cout << endl << endl;
	}

	{	// unordered_set에서 찾기
		cout << "unordered_set에 데이터 넣는 중..." << endl;
		unordered_set<int> us{ numbers.begin(), numbers.end() };
		cout << "unordered_set에서 찾는 중..." << endl;
		int cnt = 0;

		// 시간재기 시작
		auto start = chrono::steady_clock::now();
		for (int num : toFind) {
			if (us.contains(num)) {
				cnt++;
			}
		}

		// 시간재기 끝
		auto end = chrono::steady_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::microseconds>(end - start).count();	// 시간간격 duration

		cout << endl;
		cout << "걸린 시간(us) - " << elapsedTime << endl;
		cout << "찾은 수       - " << cnt << endl;
		cout << endl << endl;
	}

	{	// 정렬된 vector에서 찾기
		cout << "vector에 데이터 넣는 중..." << endl;
		vector<int> v{ numbers.begin(), numbers.end() };
		cout << "vector를 정렬하는 중" << endl;
		sort(v.begin(), v.end());
		cout << "정렬된 vector에서 찾는 중..." << endl;
		int cnt = 0;

		// 시간재기 시작
		auto start = chrono::steady_clock::now();
		for (int num : toFind) {
			if (binary_search(v.begin(), v.end(), num)) {
				cnt++;
			}
		}

		// 시간재기 끝
		auto end = chrono::steady_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::microseconds>(end - start).count();	// 시간간격 duration

		cout << endl;
		cout << "걸린 시간(us) - " << elapsedTime << endl;
		cout << "찾은 수       - " << cnt << endl;
		cout << endl << endl;
	}
	save("소스.cpp");
}


==================================================
소스.cpp2023-05-31 수요일 오후 9:41:08
==================================================
// 2023. 5. 29 월										(13주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// algorithm
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

template<class Iter, class Pred>
bool my_all_of(Iter b, Iter e, Pred p) {
	while (b != e) {
		if (p(*b) == false) {
			return false;
		}
		++b;
	}
	return true;
}

//--------
int main()
//--------
{
	vector<int> v{ -100, 3, 5, 7, 9 };
	// [문제] v의 원소가 전부 홀수인지 검사한다

	bool res = my_all_of(v.begin(), v.end(), [](int i) {
		return i & 1;
		});
	cout << boolalpha << "홀수? - " << res << endl;

	save("소스.cpp");
}


==================================================
소스.cpp2023-05-31 수요일 오후 9:43:25
==================================================
// 2023. 5. 29 월										(13주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// algorithm
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

template<class Iter, class Pred>
bool my_all_of(Iter b, Iter e, Pred p) {
	while (b != e) {
		if (p(*b) == false) {
			return false;
		}
		++b;
	}
	return true;
}

//--------
int main()
//--------
{
	String s{ "algorithmallof" };
	// [문제] s의 원소가 전부 소문자인지 검사한다

	bool res = my_all_of(s.begin(), s.end(), [](char c) {
		return islower(c);
		});
	cout << boolalpha << "모두 소문자? - " << res << endl;

	save("소스.cpp");
}


==================================================
소스.cpp2023-05-31 수요일 오후 9:55:52
==================================================
// 2023. 5. 29 월										(13주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// algorithm
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

// 컨테이너가 2개 이상이 있을 때 
// 첫 컨테이너는 전체 구간을 알려줘야 하고
// 두번째 컨테이너는 구간의 시작만 알려줘도 충분하다.

//--------
int main()
//--------
{
	vector<int> v1 { 1, 2, 3, 4, 5, 6, 7 };
	vector<int> v2 { 1, 2, 3, 4, 5, 6, };

	auto p = mismatch(v1.begin(), v1.end(), v2.begin() );
	if (p.first != v1.end()) {
		cout << "v1의 위치 - " << *p.first << endl;
	}

	if (p.second != v2.end()) {
		cout << "v2의 위치 - " << *p.second << endl;
	}
	save("소스.cpp");
}


==================================================
소스.cpp2023-05-31 수요일 오후 10:08:15
==================================================
// 2023. 5. 29 월										(13주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// algorithm
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

// 흥미예제 - Lotto 번호 생성기

//--------
int main()
//--------
{
	vector<int> v;
	v.reserve(45);

	for (int i{}; i < 45; ++i) {
		v.push_back(i + 1);
	}
	for (int n : v) {
		cout << n << " ";
	}
	cout << endl << endl;

	for (int i{}; i < 100; ++i) {
		cout << "이번 주 구입할 Lotto 번호 - ";
		sample(v.begin(), v.end(), ostream_iterator<int>{cout, " "}, 6,
			default_random_engine(random_device{}()));
		cout << endl;
	}
	save("소스.cpp");
}


==================================================
소스.cpp2023-05-31 수요일 오후 10:18:48
==================================================
// 2023. 5. 29 월										(13주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// algorithm
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <format>
#include <string>
#include <thread>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

// 흥미예제 - 전광판 예제

//--------
int main()
//--------
{
	std::string s{ "C++ STL Containers Iterators Algorithms " };
	save("소스.cpp");

	for (int i{}; i < 5; ++i) {
		cout << endl;
	}

	while (true) {
		cout << format( "{:^79}", s);
		this_thread::sleep_for(100ms);
		rotate(s.begin(), s.begin() + 1, s.end());		// 오른쪽으로 돌아가게 하려면 s.end() - 1
		cout << '\r';
	}

}


==================================================
소스.cpp2023-05-31 수요일 오후 10:19:37
==================================================
// 2023. 5. 29 월										(13주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// algorithm
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <format>
#include <string>
#include <thread>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

// 흥미예제 - 전광판 예제

//--------
int main()
//--------
{
	std::string s{ "C++ STL Containers Iterators Algorithms " };
	save("소스.cpp");

	for (int i{}; i < 5; ++i) {
		cout << endl;
	}

	while (true) {
		cout << format( "{:^79}", s);
		this_thread::sleep_for(100ms);
		shift_left(s.begin(), s.end(), 1);		// shift_right(s.begin(), s.end(), 1);
		cout << '\r';
	}

}


==================================================
소스.cpp2023-05-31 수요일 오후 10:34:13
==================================================
// 2023. 5. 29 월										(13주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// algorithm
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <format>
#include <string>
#include <thread>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	vector<int> v{ 1, 2, 3, 4, 5, 6 };

	copy(v.begin(), v.end() - 1, v.begin() + 1);

	for (int n : v) {
		cout << n << ' ';
	}
	cout << endl;
	save("소스.cpp");
}



==================================================
소스.cpp2023-05-31 수요일 오후 11:09:42
==================================================
// 2023. 5. 29 월										(13주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// algorithms - sort 관련 함수들(복잡도가 낮은 거 부터)
// partition    - 기준에 따라 분리
// nth_element  - 기준에 맞는 n개를 분리
// partial_sort - n개까지만 정렬
// sort         - 기준에 따라 모든 원소를 정렬
// stable_sort  - 상대적인 순서를 변경하지 않으면서 모든 원소를 정렬
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <format>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

default_random_engine dre;

//--------
int main()
//--------
{
	// 자료준비
	vector<int> v(100);
	for (int i{}; i < 100; ++i) {
		v[i] = i + 1;
	}

	{	// partition - odd / even
		shuffle(v.begin(), v.end(), dre);			// 자료를 섞는다
		for (int n : v) {
			cout << format( "{:4}", n );
		}
		cout << endl << endl;

		auto p = partition(v.begin(), v.end(), [](int n) {
			return n % 2 == 1;
			});
		cout << "partition 결과" << endl << endl;
		cout << "odd numbers" << endl;
		for (auto i = v.begin(); i != p; ++i) {
			cout << format("{:4}", *i);
		}
		cout << endl;
		cout << "even numbers" << endl;
		for (auto i = p; i != v.end(); ++i) {
			cout << format("{:4}", *i);
		}
		cout << endl << endl;
	}

	{
		// nth_element
		shuffle(v.begin(), v.end(), dre);			// 자료를 섞는다
		for (int n : v) {
			cout << format("{:4}", n);
		}
		cout << endl << endl;

		cout << "nth_element 결과" << endl << endl;
		nth_element(v.begin(), v.begin() + 30, v.end());
		
		cout << "nth_element 통과" << endl;
		for (auto p = v.begin(); p != v.begin() + 30; ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl;

		cout << "nth_element 통과하지 못함" << endl;
		for (auto p = v.begin() + 30; p != v.end(); ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl;

	}

	{
		// partial_sort
		shuffle(v.begin(), v.end(), dre);			// 자료를 섞는다
		for (int n : v) {
			cout << format("{:4}", n);
		}
		cout << endl << endl;

		cout << "partial_sort 30개까지 정렬한 결과" << endl << endl;
		partial_sort(v.begin(), v.begin() + 30, v.end());

		cout << "정렬된 30개" << endl;
		for (auto p = v.begin(); p != v.begin() + 30; ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl;

		cout << "나머지 70개" << endl;
		for (auto p = v.begin() + 30; p != v.end(); ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl;

	}

	{
		// sort
		shuffle(v.begin(), v.end(), dre);			// 자료를 섞는다
		for (int n : v) {
			cout << format("{:4}", n);
		}
		cout << endl << endl;

		cout << "정렬한 결과" << endl << endl;
		sort(v.begin(), v.end());

		for (auto p = v.begin(); p != v.end(); ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl;

	}

	save("소스.cpp");
}


==================================================
소스.cpp2023-05-31 수요일 오후 11:18:45
==================================================
// 2023. 5. 29 월										(13주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// algorithms - sort 관련 함수들(복잡도가 낮은 거 부터)
// partition    - 기준에 따라 분리
// nth_element  - 기준에 맞는 n개를 분리
// partial_sort - n개까지만 정렬
// sort         - 기준에 따라 모든 원소를 정렬
// stable_sort  - 상대적인 순서를 변경하지 않으면서 모든 원소를 정렬
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <format>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uid{ 1, 20 };
uniform_int_distribution<int> uidChar{ 'a', 'z' };

struct Dog {
	int num;
	char c;

	Dog() {
		num = uid(dre);
		c = uidChar(dre);
	}
};

//--------
int main()
//--------
{
	// 자료준비
	vector<Dog> dogs(100);

	// 글자 c 기준 정렬
	sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.c < b.c;
		});

	// 숫자 num 기준 정렬 - 글자 c 기준으로 정렬한 순서를 지키면서 
	stable_sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.num < b.num;
		});

	
	for (const Dog& dog : dogs) {
		cout << dog.c << " - " << dog.num << endl;
	}

	save("소스.cpp");
}


==================================================
소스.cpp2023-06-01 목요일 오전 2:13:15
==================================================
// 2023. 6. 1  목										(14주 1일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// distance를 구현한다 - iterator operation
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	vector<int> v{ 1, 2, 3, 4, 5 };

	cout << distance(v.begin(), v.end()) << endl;
	cout << distance(v.end(), v.begin()) << endl;
	save("소스.cpp");
}


==================================================
소스.cpp2023-06-01 목요일 오전 2:22:40
==================================================
// 2023. 6. 1  목										(14주 1일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// distance를 구현한다 - iterator operation
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <forward_list>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

template<class iter>
int my_distance(iter b, iter e) {
	return e - b;
}

//--------
int main()
//--------
{
	vector<int> v{ 1, 2, 3, 4, 5 };

	cout << my_distance(v.begin(), v.end()) << endl;
	save("소스.cpp");
}


==================================================
소스.cpp2023-06-01 목요일 오후 2:08:56
==================================================
// 2023. 6. 1 목										(14주 1일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// distance를 구현한다 - iterator operation
// tag dispatching
// constexpr if
// concept
//===========================================================================
#include <iostream>
#include <set>
#include <vector>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

template<class iter>
int my_distance(iter b, iter e) {
	
	// 전달된 타입 T의 여분의 정보를 알아보기 수단 = type_traits
	
	// 만일 iter가 random_access_iterator_tag 라면
	if (typeid(iterator_traits<iter>::iterator_category)
		== typeid(random_access_iterator_tag)) {
		cout << "랜덤액세스 반복자가 전달되었다" << endl;
		return e - b;
	}

	// iter가 적어도 foward_iterator라면
	int cnt = 0;
	while (b != e) {
		++b;
		++cnt;
	}

	return cnt;
}

//--------
int main()
//--------
{
	vector<int> s{ 1, 2, 3, 4, 5 };

	cout << my_distance(s.end(), s.begin()) << endl;

	// set은 트리형태로 노드로 연결되어 있음
	save("소스.cpp");
}


==================================================
소스.cpp2023-06-01 목요일 오후 2:22:56
==================================================
// 2023. 6. 1 목										(14주 1일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// distance를 구현한다 - iterator operation
// tag dispatching - C++17이전에 적합한 함수를 호출하는 기법
// constexpr if    - 소스코드를 선택적으로 확장한다
// concept
//===========================================================================
#include <iostream>
#include <set>
#include <vector>
#include <list>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

template<class iter>
int my_distance(iter b, iter e) {
	
	// 전달된 타입 T의 여분의 정보를 알아보기 수단 = type_traits
	
	// 만일 iter가 random_access_iterator_tag 라면
	if constexpr (typeid(iterator_traits<iter>::iterator_category)
		== typeid(random_access_iterator_tag)) {
		cout << "랜덤액세스 반복자가 전달되었다" << endl;
		return e - b;
	}

	// iter가 적어도 foward_iterator라면
	int cnt = 0;
	while (b != e) {
		++b;
		++cnt;
	}

	return cnt;
}

//--------
int main()
//--------
{
	list<int> l{1, 2, 3, 4, 5};

	cout << my_distance(l.end(), l.begin()) << endl;
	save("소스.cpp");
}


==================================================
소스.cpp2023-06-01 목요일 오후 2:46:59
==================================================
// 2023. 6. 1 목										(14주 1일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// distance를 구현한다 - iterator operation
// tag dispatching - C++17이전에 적합한 함수를 호출하는 기법
// constexpr if    - 소스코드를 선택적으로 확장한다
// concept
//===========================================================================
#include <iostream>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

template<class T>
T add(T a, T b){
	return a + b;
}

//--------
int main()
//--------
{
	cout << add(3, 4) << endl;
	cout << add(3.3, 4.4) << endl;
	cout << add(String{ "123" }, String{ "456" }) << endl;
	
	save("소스.cpp");
}

==================================================
소스.cpp2023-06-01 목요일 오후 2:52:29
==================================================
// 2023. 6. 1 목										(14주 1일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// distance를 구현한다 - iterator operation
// tag dispatching - C++17이전에 적합한 함수를 호출하는 기법
// constexpr if    - 소스코드를 선택적으로 확장한다
// concept
//===========================================================================
#include <iostream>
#include "save.h"
#include "String.h"

using namespace std;
extern bool 관찰;

// 제약을 가하는 알고리즘 함수를 작성 할 수 있음
template<integral T>		// integral 은 concept
T add(T a, T b){
	return a + b;
}

//--------
int main()
//--------
{
	save("소스.cpp");

	cout << add(3, 4) << endl;
	//cout << add(3.3, 4.4) << endl;
	//cout << add(String{ "123" }, String{ "456" }) << endl;

}

==================================================
소스.cpp2023-06-01 목요일 오후 3:04:45
==================================================
// 2023. 6. 1 목										(14주 1일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// C++20 - 4 major change
// Concept
// Range
// Module
// Coroutine
//===========================================================================
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// concept은 함수형 프로그래밍
template<class T>
concept 정수와플로트만 = integral<T> or floating_point<T>;		// class T 가 정수형과 실수형 일때만 정수와플로트만 이라는 concept 넘김

template<정수와플로트만 T>
T add(T a, T b){
	return a + b;
}

//--------
int main()
//--------
{

	cout << add(3, 4) << endl;
	cout << add(3.3, 4.4) << endl;

	save("소스.cpp");
}

==================================================
소스.cpp2023-06-01 목요일 오후 3:07:00
==================================================
// 2023. 6. 1 목										(14주 1일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// C++20 - 4 major change
// Concept
// Range
// Module
// Coroutine
//===========================================================================
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// concept은 함수형 프로그래밍
template<class T>
concept addable = integral<T> or floating_point<T>;

// 자동으로 찍어내줌
addable auto add(addable auto a, addable auto b){
	return a + b;
}

//--------
int main()
//--------
{

	cout << add(3, 4) << endl;
	cout << add(3.3, 4.4) << endl;

	save("소스.cpp");
}

==================================================
소스.cpp2023-06-01 목요일 오후 3:18:52
==================================================
// 2023. 6. 1 목										(14주 1일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
// C++20 - 4 major change
// Concept
// Range
// Module
// Coroutine
//===========================================================================
#include <iostream>
#include <ranges>
#include <algorithm>
#include <vector>
#include <random>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uidNum{ 1, 100 };
uniform_int_distribution<int> uidC{ 'A', 'Z' };
struct Dog {
	int num = uidNum(dre);
	char c = uidC(dre);
};

//--------
int main()
//--------
{
	vector<Dog> dogs(100);

	// Constrained Algorithm
	ranges::sort(dogs, {}, &Dog::num);

	for (auto [숫자, 글자] : dogs) {
		cout << 글자 << " - " << 숫자 << endl;
	}

	save("소스.cpp");
}

==================================================
소스.cpp2023-06-05 월요일 오후 2:08:09
==================================================
// 2023. 6. 5 월										(14주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
// 6. 6 업로드할 동영상 - 총정리 실습
//---------------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미(semantic)를 만족하는지를
//			 컴파일 타임에 검사(소스코드 확장 전)
// Range   - composable / less error-prone -> lazy evalutation(지연 평가)
//  - [begin, end)
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	vector<int> v{ 3 ,8 ,6, 1, 2, 9, 4, 10, 7, 5 };

	// [begin, end)
	// sort(v.begin(), v.end()) 를 ranges를 사용하면 ranges안에서 v.begin, v.end를 자동으로 찍어줌
	ranges::sort(v);

	// range for -> v는 range로 (v.begin(), v.end()) 와 같은 말
	for (int n : v) {
		cout << n << ' ';
	}
	cout << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-06-05 월요일 오후 2:11:58
==================================================
// 2023. 6. 5 월										(14주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
// 6. 6 업로드할 동영상 - 총정리 실습
//---------------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미(semantic)를 만족하는지를
//			 컴파일 타임에 검사(소스코드 확장 전)
// Range   - composable / less error-prone -> lazy evalutation(지연 평가)
//  - [begin, end)
//  - [start, size)
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	vector<int> v{ 3, 8, 6, 1, 2, 9, 4, 10, 7, 5 };
	// [start, size)

	// 정렬하는 범위를 정할 수 있음
	ranges::sort(views::counted(&v[1], 5));	// &v[1] == v.begin() + 1

	for (int n : v) {		// 여기서 v는 views::counted(&v[0], 10)와 같은 말
		cout << n << ' ';
	}
	cout << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-06-05 월요일 오후 2:17:10
==================================================
// 2023. 6. 5 월										(14주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
// 6. 6 업로드할 동영상 - 총정리 실습
//---------------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미(semantic)를 만족하는지를
//			 컴파일 타임에 검사(소스코드 확장 전)
// Range   - composable / less error-prone -> lazy evalutation(지연 평가)
//  - [begin, end)
//  - [start, size)
//  - [start, predicate)
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	vector<int> v{ 4, 3, 1, 2, 8, 6, 1, 2, 9, 4, 10, 7, 5 };
	// [start, predicate)

	// 5보다 작은 애들만 정렬
	ranges::sort(views::take_while(v, [](int n) { return n < 5; }));

	// views::take_while(v, [](int n){ return n < 5;}) - v에서 5보다 작은 애들만 출력
	for (int n : v) {
		cout << n << ' ';
	}
	cout << endl;
	save("소스.cpp");
}

==================================================
소스.cpp2023-06-05 월요일 오후 2:32:39
==================================================
// 2023. 6. 5 월										(14주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
// 6. 6 업로드할 동영상 - 총정리 실습
//---------------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미(semantic)를 만족하는지를
//			 컴파일 타임에 검사(소스코드 확장 전)
// Range   - composable / less error-prone -> lazy evalutation(지연 평가)
//  - [begin, end)
//  - [start, size)
//  - [start, predicate)
//  - [start..)
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// [start..)
	save("소스.cpp");

	for (int n : views::iota(numeric_limits<int>::max() - 5000)) {
		cout << n << ' ';
	}
	cout << endl;

}

==================================================
소스.cpp2023-06-05 월요일 오후 2:38:00
==================================================
// 2023. 6. 5 월										(14주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
// 6. 6 업로드할 동영상 - 총정리 실습
//---------------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미(semantic)를 만족하는지를
//			 컴파일 타임에 검사(소스코드 확장 전)
// Range   - composable / less error-prone -> lazy evalutation(지연 평가)
//  - [begin, end)
//  - [start, size)
//  - [start, predicate)
//  - [start..)
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	vector<int> v{ 1, 2, 3, 4, 5 };

	auto 범위 = views::counted(v.begin(), 3);

	// 이렇게 사용하면 범위는 경량객체가 됨
	cout << 범위.size() << endl;
	save("소스.cpp");

}

==================================================
소스.cpp2023-06-05 월요일 오후 2:54:55
==================================================
// 2023. 6. 5 월										(14주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
// 6. 6 업로드할 동영상 - 총정리 실습
//---------------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미(semantic)를 만족하는지를
//			 컴파일 타임에 검사(소스코드 확장 전)
// Range   - composable / less error-prone -> lazy evalutation(지연 평가)
//  - [begin, end)
//  - [start, size)
//  - [start, predicate)
//  - [start..)
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

bool isPrime(int n) {
	for (int i = 2; i <= sqrt(n); ++i) {
		if (n % i == 0) {
			return false;
		}
	}
	return true;
}

//--------
int main()
//--------
{
	// 소수(prime num : 2, 3, 5, 7, 11, 13)를 영원히 출력하라
	// 100만 이상의 수 중에서 100개만 출력하라

	auto 백만이하 = [](int n) { return n <= 100'0000;  };

	for (int n : views::iota(2)
				| views::drop_while(백만이하)
				| views::filter(isPrime)
				| views::take(100)
		) {
		cout << n << ' ';
	}
	save("소스.cpp");

}

==================================================
소스.cpp2023-06-05 월요일 오후 2:56:40
==================================================
// 2023. 6. 5 월										(14주 2일)
// 15주 2일 6. 12 월요일 - 기말시험
// 6. 6 업로드할 동영상 - 총정리 실습
//---------------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미(semantic)를 만족하는지를
//			 컴파일 타임에 검사(소스코드 확장 전)
// Range   - composable / less error-prone -> lazy evalutation(지연 평가)
//  - [begin, end)
//  - [start, size)
//  - [start, predicate)
//  - [start..)
//===========================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

bool isPrime(int n) {
	for (int i = 2; i <= sqrt(n); ++i) {
		if (n % i == 0) {
			return false;
		}
	}
	return true;
}

//--------
int main()
//--------
{
	// 소수(prime num : 2, 3, 5, 7, 11, 13)를 영원히 출력하라
	// 100만 이상의 수 중에서 100개만 뒤에서부터 출력하라

	auto 백만이하 = [](int n) { return n <= 100'0000;  };

	for (int n : views::iota(2)
				| views::drop_while(백만이하)
				| views::filter(isPrime)
				| views::take(100)
				| views::reverse
		) {
		cout << n << ' ';
	}

	save("소스.cpp");

}

==================================================
소스.cpp2023-06-08 목요일 오후 2:49:51
==================================================
// 2023. 6. 8 목										(15주 1일)
// 15주 2일 6. 12 월요일 - 기말시험
//---------------------------------------------------------------------------
//===========================================================================
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// C++ PL
	// - Generic PL -> 자료형에 무관하게 함수와 클래스를 작성할 수 있음
	// - 파일 입출력 -> 데이터를 가져올 때 메모리 영역이 구분되어 있어 사용 용도가 다름 (&& R-value reference)
	// - smart pointer -> RAII(함수가 종료될때 메모리를 자동으로 해제해줌), nullptr/null배열 사용금지
	// - 호출가능 타입 -> 클래스를 호출할 수 있음(연산자 오버로딩을 하고있으면) -> 함수 객체 / lambda : 전역/지역 클래스, 함수를 찍어내는 틀(closure)
	// - 관찰클래스 STRING을 만들어서 작동 원리를 관찰할 수 있음
	//		{ Container - 1. Sequence container	{ array<T, N>	}
	//		{				시간복잡도 : O(N)	{ vector<T>		} + T[N], std::string, String : 이러한 contiguous한 메모리 타입의 자료형을 span<T> 이라고함
	//		{									{ deque<T>		}
	//		{									{ list<T>
	//		{									{ forward_list<T>
	//		[									+ adpator
	//		{			  2. Associative container { set<key, <>
	//		{				시간복잡도 : O(log2N)   { multi_set
	//		{									   { map<key, value, <>
	//		{									   { multi_map
	//		{			  3. Unordered Associative container { unordered_set<key, hash>
	//		{				시간복잡도 : O(1)				 { unordered_multiset
	//		{				빨리찾기 용도				     { unordered_map<key, value, hash>
	//		{												 { unordered_multimap
	// STL -{ Iterator - 자료구조를 일관되게 순회할 수 있도록 해줌, pointer와 유사
	//		{			Category(hierachy)
	//		{				input_iterator, output_iterator
	//		{				forward_iterator
	//		{				bidirectional_iterator
	//		{				random_access_iterator
	//		{			-> contiguous_iterator(C++20 concept)
	//		{			
	//		{			iterator_traits<T> :: 5가지 traits
	//		{			반복자는 container가 제공하는 class 이어야 함
	//		{			String_iterator
	//		{			String_recerse_iteterator -> 반복자의 interface를 갖지만 행동은 적절하게
	//		{									  -> adaptor : istream_iterator, ostream_iterator
	//		{ Algorithm - iterator 범위 내에서 작동됨
	//		{			  classification - { 1. Non-modifying sequence operations
	//		{							   { 2. Mutating sequence operations
	//		{							   { 3. Sort and realted operations
	//		{			알고리즘 함수가 for loop 보다 좋은 이유
	//		{							1. error가 생길 가능성이 줄음
	//		{							2. sort의 경우 람다 함수가 inline 으로 들어가서 쓸데없는 함수 호출을 줄여 속도를 극대화 함
	//		{							3. 동시성을 가질 수 있어 성능을 대폭 향상 시킬수 있음
	//		{			  iterator 함수인 distance 작성 -> 반복자 종류에 맞는 효율적인 coding 예
	//		{			=> concept으로 다시 작성 -> constrained algorithms
	//		{			+ range, view -> functional programming가능(conpasable)

	save("소스.cpp");

}

==================================================
소스.cpp2023-06-10 토요일 오후 8:10:23
==================================================
// 2023 STL 총정리 실습 - 에너그램 찾기
// - 단어들을 컨테이너에 저장한다 - 369882 단어가 있음
// - 정렬되어 있나? - True
// - 중복된 단어 - 없다
// - 길이가 가장 긴 단어 - 31 글자 : dichlorodiphenyltrichloroethane
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anargram을 출력한다 (anargram은 단어의 문자의 순사를 바꾸어 다른 단어로 만드는 것)
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include <ranges>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	save("소스.cpp");

	ifstream in{ "단어들.txt" };
	if (!in) {
		cout << "파일을 열 수 없습니다" << endl;
		exit(0);
	}

	vector<string> v;
	v.reserve(10'0000);

	copy(istream_iterator<string>{in}, {}, back_inserter(v));	// back_inserter??
	cout << "읽은 단어 수 - " << v.size() << endl;
	
	cout << "정렬되어 있나? - " << boolalpha << is_sorted(v.begin(), v.end()) << endl;

	// 중복된 단어가 있는지 확인하지만 중복된 단어를 삭제함
	auto p = unique(v.begin(), v.end());
	if (p == v.end()) {
		cout << "중복된 단어는 없다" << endl;
	}
	else {
		cout << "중복된 단어가 있다" << endl;
	}

	// 길이가 가장 긴 단어
	auto it = max_element(v.begin(), v.end(), [](const string& a, const string& b) {
		return a.size() < b.size();
		});
	cout << "가장 긴 단어 - " << it->size() << "글자 : " << *it << endl;

	// 길이가 12글자 짜리 단어 몇 개를 화면에 출력해 본다
	// 글자 수가 커지면은 안돌아감 -> n 팩토리얼의 크기가 long long 타입의 범위를 넘어가기 때문
	cout << "원하는 글자 수를 입력하세요 : ";
	int num = 0;
	cin >> num;

	for (const string& s : v | views::filter([](const string& s) { return s[0] == 'c'; })
							 | views::filter([num](const string& s) {return s.size() == num; }) 
							 | views::take(10)) {
		cout << s << endl;
	}


	// anagram을 찾는 프로그램이다
	// 사용자가 입력한 단어와 anargram 관계에 있는 단어를 모두 출력한다
	
	cout << endl;
	cout << "=======================" << endl;
	cout << "애너그램을 찾아드립니다" << endl;
	cout << "=======================" << endl;

	while (true) {
		cout << "찾을 단어를 입력하세요: ";
		string toFind;
		cin >> toFind;

		if (!binary_search(v.begin(), v.end(), toFind)) {
			cout << "사전에 없는 단어입니다" << endl << endl;
			continue;
		}

		// 애너그램을 찾아 표시한다
		cout << "가능한 조합의 개수 - ";
		long long pNum = 1;
		for (int i = 0; i < toFind.size(); ++i) {
			pNum *= i + 1;
		}
		cout << pNum << endl << endl;

		string word = toFind;
		sort(word.begin(), word.end());

		do {
			if (binary_search(v.begin(), v.end(), word)) {
				cout << word << " ";
			}
		} while (next_permutation(word.begin(), word.end()) );	// next_permutation은 정렬된 데이터에서부터 시작하여 조합 가능한 단어들을 출력해줌 -> 찾을 단어를 정렬해야됨
		cout << endl << endl;
	}

}

==================================================
소스.cpp2023-06-10 토요일 오후 9:54:31
==================================================
// 2023 STL 총정리 실습 - 에너그램 찾기
// - 단어들을 컨테이너에 저장한다 - 369882 단어가 있음
// - 정렬되어 있나? - True
// - 중복된 단어 - 없다
// - 길이가 가장 긴 단어 - 31 글자 : dichlorodiphenyltrichloroethane
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anargram을 출력한다 (anargram은 단어의 문자의 순사를 바꾸어 다른 단어로 만드는 것)
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include <ranges>
#include "save.h"
using namespace std;

struct PS : pair<string, string> {
	PS(string s) : pair(s, s) {
		sort(first.begin(), first.end());
	}
};

//--------
int main()
//--------
{
	save("소스.cpp");

	ifstream in{ "단어들.txt" };
	if (!in) {
		cout << "파일을 열 수 없습니다" << endl;
		exit(0);
	}

	vector<PS> v;
	v.reserve(40'0000);

	string s;
	while (in >> s) {
		v.push_back(s);
	}
	cout << "단어 개수 - " << v.size() << endl;

	// v를 first 오름차순으로 정렬한다
	auto PS기준 = [](const  PS& a, const PS& b) {
		return a.first < b.first;
	};
	sort(v.begin(), v.end(), PS기준);

	// v의 일부분을 출력한다
	// 길이가 8글자인 경우만 100개

	/*cout << "어디서부터 출력할까요? ";
	int num;
	cin >> num;
	for (const auto& [정렬, 원본] : v 
		| views::drop(num)
		| views::filter([](const PS& ps){ return ps.first.size() == 5; })
		| views::take(100)) {
		cout << 정렬 << " - " << 원본 << endl;
	}*/

	while (true) {
		cout << "찾을 단어를 입력하세요 : "; 
		string s;
		cin >> s;

		PS word{ s };
		auto [하한, 상한] = equal_range(v.begin(), v.end(), word, PS기준);
		if (하한 == 상한) {
			cout << "사전에 없는 단어입니다" << endl;
			continue;
		}
		else {
			cout << s << "의 anargram들" << endl;
			for (auto p = 하한; p < 상한; ++p) {
				cout << p->second << " ";
			}
			cout << endl;
		}
	}
	
}

==================================================
소스.cpp2023-06-10 토요일 오후 9:56:28
==================================================
// 2023 STL 총정리 실습 - 에너그램 찾기
// - 단어들을 컨테이너에 저장한다 - 369882 단어가 있음
// - 정렬되어 있나? - True
// - 중복된 단어 - 없다
// - 길이가 가장 긴 단어 - 31 글자 : dichlorodiphenyltrichloroethane
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anargram을 출력한다 (anargram은 단어의 문자의 순사를 바꾸어 다른 단어로 만드는 것)
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include <ranges>
#include "save.h"
using namespace std;

struct PS : pair<string, string> {
	PS(string s) : pair(s, s) {
		sort(first.begin(), first.end());
	}
};

//--------
int main()
//--------
{
	save("소스.cpp");

	ifstream in{ "단어들.txt" };
	if (!in) {
		cout << "파일을 열 수 없습니다" << endl;
		exit(0);
	}

	vector<PS> v;
	v.reserve(40'0000);

	string s;
	while (in >> s) {
		v.push_back(s);
	}
	cout << "단어 개수 - " << v.size() << endl;

	// v를 first 오름차순으로 정렬한다
	auto PS기준 = [](const  PS& a, const PS& b) {
		return a.first < b.first;
	};
	sort(v.begin(), v.end(), PS기준);

	// 전체 anagram 쌍을 화면에 출력하라

	for (int i = 0; i < 100; ++i) {
		cout << v[i].first << " - " << v[i].second << endl;
	}
	
}


==================================================
소스.cpp2023-06-10 토요일 오후 10:05:27
==================================================
// 2023 STL 총정리 실습 - 에너그램 찾기
// - 단어들을 컨테이너에 저장한다 - 369882 단어가 있음
// - 정렬되어 있나? - True
// - 중복된 단어 - 없다
// - 길이가 가장 긴 단어 - 31 글자 : dichlorodiphenyltrichloroethane
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anargram을 출력한다 (anargram은 단어의 문자의 순사를 바꾸어 다른 단어로 만드는 것)
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include <ranges>
#include "save.h"
using namespace std;

struct PS : pair<string, string> {
	PS(string s) : pair(s, s) {
		sort(first.begin(), first.end());
	}
};

//--------
int main()
//--------
{
	save("소스.cpp");

	ifstream in{ "단어들.txt" };
	if (!in) {
		cout << "파일을 열 수 없습니다" << endl;
		exit(0);
	}

	vector<PS> v;
	v.reserve(40'0000);

	string s;
	while (in >> s) {
		v.push_back(s);
	}
	cout << "단어 개수 - " << v.size() << endl;

	// v를 first 오름차순으로 정렬한다
	auto PS기준 = [](const  PS& a, const PS& b) {
		return a.first < b.first;
	};
	sort(v.begin(), v.end(), PS기준);

	// [문제] 전체 anagram 쌍을 화면에 출력하라

	auto i = v.begin();
	int cnt{};
	while (true) {
		i = adjacent_find(i, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
			});
		if (i == v.end()) {
			break;
		}

		// 그렇다면 i와 i+1의 first는 같다
		auto j = find_if_not(i + 1, v.end(), [i](const PS& a) {
			return i->first == a.first;
			});

		// [i, j) 는 애너그램 쌍이다
		cout << "[" << ++cnt << "] - ";
		for (auto k = i; k < j; ++k) {
			cout << k->second << " ";
		}
		cout << endl;

		i = j;
	}
	
}

==================================================
소스.cpp2023-06-10 토요일 오후 10:22:37
==================================================
// 2023 STL 총정리 실습 - 에너그램 찾기
// - 단어들을 컨테이너에 저장한다 - 369882 단어가 있음
// - 정렬되어 있나? - True
// - 중복된 단어 - 없다
// - 길이가 가장 긴 단어 - 31 글자 : dichlorodiphenyltrichloroethane
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anargram을 출력한다 (anargram은 단어의 문자의 순사를 바꾸어 다른 단어로 만드는 것)
//===========================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include <ranges>
#include <list>
#include "save.h"
using namespace std;

struct PS : pair<string, string> {
	PS(string s) : pair(s, s) {
		sort(first.begin(), first.end());
	}
};

//--------
int main()
//--------
{
	save("소스.cpp");

	ifstream in{ "단어들.txt" };
	if (!in) {
		cout << "파일을 열 수 없습니다" << endl;
		exit(0);
	}

	vector<PS> v;
	v.reserve(40'0000);

	string s;
	while (in >> s) {
		v.push_back(s);
	}
	cout << "단어 개수 - " << v.size() << endl;

	// v를 first 오름차순으로 정렬한다
	auto PS기준 = [](const  PS& a, const PS& b) {
		return a.first < b.first;
	};
	sort(v.begin(), v.end(), PS기준);

	// [문제] 전체 anagram 쌍을 컨테이너에 저장하라
	vector<list<string>> anagrams;


	auto i = v.begin();
	int cnt{};
	while (true) {
		i = adjacent_find(i, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
			});
		if (i == v.end()) {
			break;
		}

		// 그렇다면 i와 i+1의 first는 같다
		auto j = find_if_not(i + 1, v.end(), [i](const PS& a) {
			return i->first == a.first;
			});

		// [i, j) 는 애너그램 쌍이다
		list<string> con;
		for (auto k = i; k < j; ++k) {
			con.push_back(k->second);
		}
		anagrams.push_back(con);

		i = j;
	}

	cout << "모두 " << anagrams.size() << "개의 애너그램 쌍을 찾았습니다" << endl;

	// 애너그램 개수가 많은 순서대로 정렬
	sort(anagrams.begin(), anagrams.end(), [](const list<string> a, const list<string> b) {
		return a.size() > b.size();
		});

	for (int i = 0; i < 10; ++i) {
		cout << anagrams[i].size() << " - ";
		for (const string& word : anagrams[i]) {
			cout << word << " ";
		}
		cout << endl;
	}

}